<!DOCTYPE html>
<html lang="en">
<head>
  <title>Image Generator</title>
  <meta charset="utf-8"/>
  <script type="text/javascript">

//////////////////////////////////////////////////////
//
// Author:      Richard Czegledi
// Date:        July 6, 2018
//
// ID Legend:
//  $("_canvas")    - canvas element for drawing image
//  $("_debug")     - checkbox for enabling debug mode
//  $("_myURL")     - URL name with parameters
//  $("_profile")   - profile name
//  $("_imageInput") - elements for accepting image URL

//  $("t1")         - title string 1
//  $("t2")         - title string 2
//  $("tp")         - title part (e.g. "Group A")
//  $("tff")        - title font family
//  $("tfb")        - title font bold selected
//  $("tfi")        - title font italic selected 
//  $("tfs")        - title font shadow selected
//  $("tfp")        - title font size
//  $("tc")         - title colour
//  $("tpc")        - title part colour

//  $("rep")        - recipient name in center of torus
//  $("rff")        - recipient font family
//  $("rfb")        - recipient font bold selected
//  $("rfi")        - recipient font italic selected
//  $("rfs")        - recipient font shadow selected
//  $("rfp")        - recipient font size
//  $("rc")         - recipient colour

//  $("tr#")        - trash member/master # (from 0)

//  $("p#")         - member # (from 0)
//  $("pff")        - member font family
//  $("pfb")        - member font bold selected
//  $("pfi")        - member font italic selected
//  $("pfs")        - member font shadow selected
//  $("pfp")        - member font size
//  $("pc")         - member colour

//  $("m#")         - master # (from 0)
//  $("mff")        - master font family
//  $("mfb")        - master font bold selected
//  $("mfi")        - master font italic selected
//  $("mfs")        - master font shadow selected
//  $("mfp")        - master font size
//  $("mc")         - master colour

//  $("bgc")        - background colour
//  $("o")          - orientation
//  $("or")         - torus addition order
//  $("tors")       - torus size in px
//  $("torw")       - torus width in px
//  $("torc")       - torus colour
//  $("tort")       - torus treatment
//  $("tortc")      - torus treament colour
//  $("torpc")      - torus peg colour
//  $("torpbc")     - torus peg border colour
//  $("tori")       - torus image
//  $("pegt")       - peg treatment
//  $("pegw")       - peg width
//  $("_error")     - error string
//  $("f")          - image filename

var g_Debug = false;

var ALIGNMENT = { LEFT:0, CENTER:1, RIGHT:2, AUTO:3 };

var OBJECT_TYPE = { TITLE:0, MEMBER:1, MASTER:2, RECIPIENT:3};

var TORUS_TREATMENT = { NONE:0, HEART:1, RANDOM:2, FLOWER_OF_LIFE:3, METATRONS_CUBE:4,
                        DAISY:5, PETALS:6,
                        MESH:7, GEOMETRIC_1:8, IMAGE:9};

var PEG_TREATMENT = { NONE:0, CIRCLE:1, SQUARE:2, DIAMOND:3, HEART:4 };

var g_DragSrcEl = null;

var g_TorusImage = null;

var g_TorusTreament = TORUS_TREATMENT.NONE;

var g_PegTreatment = PEG_TREATMENT.CIRCLE;

var g_CORSEnabled = true;

var g_AllMembers = [];

// NOTE: font description MUST include the font height in 'px'.
var g_RecipientFontDesc = { 
    fontFamilyID:               "rff",
    fontBoldID:                 "rfb",
    fontItalicID:               "rfi",
    fontSizeID:                 "rfp",
    fontShadowID:               "rfs",

    textColorID:                "rc",
    debugColor:                 "green",

    torusColorID:               "torc",         // extra colour attribute for torus
    torusPegColorID:            "torpc",        // extra colour attribute for torus peg
    torusPegBorderColorID:      "torpbc",       // extra colour attribute for torus peg border 
    torusTreatmentColorID:      "tortc",        // extra colour attribute for torus treatment
    imageColor:                 "white"         // extra colour attribute for image
};

var g_TitleFontDesc = { 
    fontFamilyID:               "tff",
    fontBoldID:                 "tfb",
    fontItalicID:               "tfi",
    fontSizeID:                 "tfp",
    fontShadowID:               "tfs",

    textColorID:                "tc",
    titleGroupColorID:          "tpc",        // extra color attribute to title group
    debugColor:                 "green"
};

var g_MemberFontDesc = { 
    fontFamilyID:               "pff",
    fontBoldID:                 "pfb",
    fontItalicID:               "pfi",
    fontSizeID:                 "pfp",
    fontShadowID:               "pfs",

    textColorID:                "pc",
    debugColor:                 "green"
};

var g_MasterFontDesc = { 
    fontFamilyID:               "mff",
    fontBoldID:                 "mfb",
    fontItalicID:               "mfi",
    fontSizeID:                 "mfp",
    fontShadowID:               "mfs",

    textColorID:                "mc",
    debugColor:                 "green"
};

var g_ElementDefaults = {
                        // Font Family      bold?       italic?      shadow?        Font Size   Text Color
    /* Title */         tff:"Arial",        tfb:"true", tfi:"false", tfs:"false",   tfp:"16px", tc:"3605FF",       
    /* Recipient */     rff:"Arial",        rfb:"true", rfi:"false", rfs:"false",   rfp:"14px", rc:"14811E",
    /* Member */        pff:"Arial",        pfb:"true", pfi:"false", pfs:"false",   pfp:"14px", pc:"000000",
    /* Master */        mff:"Arial",        mfb:"true", mfi:"false", mfs:"false",   mfp:"14px", mc:"000000",

    t1:"Group Torus",   // Title 1 string

    o:"270",            // orientation
    or:"counter",       // counter-clockwise additions

    bgc:"FFFFFF",       // background colour
    tors:"100",         // torus size
    torw:"3",           // torus circle width
    tort:"0",           // torus treatment
    tortc:"000000",     // torus treatment colour
    tpc:"FF15C8",       // title group color
    pegt:"1",           // peg treatment
    pegw:"6",           // peg width

    torc:"000000",      // torus color
    torpc:"FF0000",     // torus peg color
    torpbc:"000000",    // torus peg border colour
    pc:"000000",        // member color
    mc:"FF0000"         // master color
};

var g_MastersList = [
    "",

    // Ascended Masters
    "Mary Magdalene",               "Jesus",                "St Germain",
    "El Morya",                     "Dom Ignacio",          "Lady Nada",
    "Lao Tze",                      "Paul The Venetian",    "Melchizedek",
    "Maha Chohan",                  "Kuan Yin",             "Hilarion",
    "Kuthumi",                      "Lord Lanto",           "Pallas Athena",
    "Mother Mary",                  "Isis",                 "Serapis Bey",
    "St John, the Baptist",         "Eros",                 "Ma'at",
    "Amen Bey",                     "Ptah",                 "Thomas Merton",
    "Portia",                       "Anubis",               "Quetzacoatl",
    "Freya",                        "Moses",                "Vesta",
    "Chananda",                     "Yogananda",            "Gautama Buddha",
    "Maitreya",                     "Cha Ara",              "Hinenuitepo",
    "St Anthony of Padua",          "Pele",

    // Archangels
    "AA Michael",                   "AA Charity",           "AA Uzziel",
    "AA Christine",                 "AA Jophiel",           "AA Hope",
    "AA Chamuel",                   "AA Faith",             "AA Gabriel",
    "AA Raphael",                   "AA Ariel",             "AA Aurora",
    "AA Uriel",                     "AA Amethyst",          "AA Zadkiel",

    // Cosmic Masters
    "White Tara",                   "Ganesh",               "Sanat Kumara",
    "Susan'oo",                     "Ra-mun",               "Vishnu",
    "Helios",                       "Shiva",                "Osiris",
    "Ares",                         "Metatron",             "Sitatapatra",
    "Krishna",                      "Amaryllis",            "Hathor",
    "Inanna",                       "Amaterasu",            "Omri Tas",
    "Lakshmi",

    // Elohim
    "Amazonia",                     "Hercules",             "Apollo",
    "Lumina",                       "Heros",                "Amora",
    "Purity",                       "Cyclopea",             "Virginia",
    "Astrea",                       "Cassiopea",            "Peace",
    "Aloha",                        "Arcturus",             "Victoria",
    "Elohim of the 8th ray" ];


// Object to define origin within canvas.
var g_Origin = {
    // Center X,Y coordinates of center circle.
    imageWidth:                 800,
    imageHeight:                800,

    imageCenterX:               400,            // imageWidth/2
    imageCenterY:               400,            // imageHeight/2

    torusRingSize:              100,            // initial size of torus circle 
    torusRingWidth:             3,              // px for the torus circle
    torusRingSpacing:           6,              // px spacing abound torus circle
    torusRingMasterSpacing:     75,             // px spacing from torus circle to master names

    torusRingPegSize:           6,              // px size of pegs on torus circle

    memberSpacing:              5,              // px spacing around member names
    masterSpacing:              5,              // px spacing around master names

    memberStartAngle:           90,             // initial angle for member name

    cropSpacing:                5,              // px spacing from entire image to border

    titleSpacing:               20,             // px spacing from title to any member/master name

    maxMembers:                 12,             // maximum number of members supported
    maxDropDownMembers:         15,             // maximum number of members in drop down list

    maxProfiles:                7,              // maximum number of cookie profiles supported
    maxCookieDays:              365,            // maximum days to keep a cookie

    absXY : function( relX, relY ) {
        return { x: Math.round( this.imageCenterX + relX ),
                 y: Math.round( this.imageCenterY + relY ) };
    },

    polarToAbsXYWithOffset : function( radius, angle, offsetX, offsetY ) {
        return this.absXY( offsetX + radius * Math.cos( angle * Math.PI / 180 ),
                           offsetY + radius * Math.sin( angle * Math.PI / 180 ) );
    },

    polarToAbsXY : function( radius, angle ) {
        return this.polarToAbsXYWithOffset( radius, angle, 0, 0 );
    },

    resetImageCenter : function() {
        this.imageCenterX = this.imageWidth / 2;
        this.imageCenterY = this.imageHeight / 2;
    },

    setImageCenter : function( x, y ) {
        this.imageCenterX = x;
        this.imageCenterY = y;
    } 
};


var g_DetectedFonts = {};
var g_Title = [];
var g_Members = [];
var g_ObjectArray = [];



function resetGlobals() {
    g_Title = [];
    g_Members = [];
    g_ObjectArray = [];
    g_Origin.resetImageCenter();
}

function resetCookies() {
    for( var i = 0; i < g_Origin.maxProfiles; ++i ) {
        eraseCookie( "profile" + i );
    }
}

/**
 * JavaScript code to detect available availability of a
 * particular font in a browser using JavaScript and CSS.
 *
 * Author : Lalit Patel
 * Website: http://www.lalit.org/lab/javascript-css-font-detect/
 * License: Apache Software License 2.0
 *          http://www.apache.org/licenses/LICENSE-2.0
 * Version: 0.15 (21 Sep 2009)
 *          Changed comparision font to default from sans-default-default,
 *          as in FF3.0 font of child element didn't fallback
 *          to parent element if the font is missing.
 * Version: 0.2 (04 Mar 2012)
 *          Comparing font against all the 3 generic font families ie,
 *          'monospace', 'sans-serif' and 'sans'. If it doesn't match all 3
 *          then that font is 100% not available in the system
 * Version: 0.3 (24 Mar 2012)
 *          Replaced sans with serif in the list of baseFonts
 */
/**
 * Usage: d = new Detector();
 *        d.detect('font name');
 */
var Detector = function() {
    // a font will be compared against all the three default fonts.
    // and if it doesn't match all 3 then that font is not available.
    var baseFonts = ['monospace', 'sans-serif', 'serif'];

    //we use m or w because these two characters take up the maximum width.
    // And we use a LLi so that the same matching fonts can get separated
    var testString = "mmmmmmmmmmlli";

    //we test using 72px font size, we may use any size. I guess larger the better.
    var testSize = '72px';

    var h = document.getElementsByTagName("body")[0];

    // create a SPAN in the document to get the width of the text we use to test
    var s = document.createElement("span");
    s.style.fontSize = testSize;
    s.innerHTML = testString;
    var defaultWidth = {};
    var defaultHeight = {};
    for (var index in baseFonts) {
        //get the default width for the three base fonts
        s.style.fontFamily = baseFonts[index];
        h.appendChild(s);
        defaultWidth[baseFonts[index]] = s.offsetWidth; //width for the default font
        defaultHeight[baseFonts[index]] = s.offsetHeight; //height for the defualt font
        h.removeChild(s);
    }

    function detect(font) {
        var detected = false;
        for (var index in baseFonts) {
            s.style.fontFamily = font + ',' + baseFonts[index]; // name of the font along with the base font for fallback.
            h.appendChild(s);
            var matched = (s.offsetWidth != defaultWidth[baseFonts[index]] || s.offsetHeight != defaultHeight[baseFonts[index]]);
            h.removeChild(s);
            detected = detected || matched;
        }
        return detected;
    }

    function identifyCommonFonts() {
        // list of 'common' fonts to search
        var commonFonts = ["cursive", "monospace", "serif", "sans-serif", "fantasy", "default", "Arial",
                           "Arial Black", "Arial Narrow", "Bookman Old Style", "Century",
                           "Century Gothic", "Comic Sans MS", "Courier", "Courier New", "Georgia", "Gentium",
                           "Impact", "King", "Lucida Console", "Lalit", "Modena", "Monotype Corsiva", "Papyrus",
                           "Tahoma", "TeX", "Times", "Times New Roman", "Trebuchet MS", "Verdana", "Verona"];
        var detectedFonts = [];

        for( var i=0; i < commonFonts.length; ++i ) {
            if( detect(commonFonts[i]) ) {
                detectedFonts.push( commonFonts[i] );
            }
        }
        return detectedFonts;
    }

    this.detect = detect;
    this.identifyCommonFonts = identifyCommonFonts;
};

function computeSeed() {
    var seed = 12345;
    for( var i = 0; i < g_Origin.maxMembers; ++i ) {
        var member = $("p" + i).value;
        var master = $("m" + i).value;
        
        if( member !== "" ) {
            for( var j = 0; j < member.length; ++j ) {
                seed = ((seed + member.charCodeAt(j)) * 53) % 0x80000000;
            }
        }
        if( master !== "" ) {
            for( var j = 0; j < master.length; ++j ) {
                seed = ((seed + master.charCodeAt(j)) * 53) % 0x80000000;
            }
        }
    }
    return seed;
}

function myRand(seed) {
    this.m = 0x80000000;    // 2**31
    this.a = 1103515245;
    this.c = 12345;
    this.state = seed ? seed : Math.floor(Math.random() * (this.m-1));
}
myRand.prototype.nextInt = function() {
    this.state = (this.a * this.state + this.c) % this.m;
    return this.state;
}
myRand.prototype.nextRange = function(start, end) {
    var rangeSize = end - start;
    var randomUnder1 = this.nextInt() / this.m;
    var value = start + Math.floor( randomUnder1 * rangeSize );
    return value;
}


function $(id) {
    return document.getElementById(id);
}

function massageName( name ) {
    var arr = [];

    // Determine if the name needs to be split.
    if( name.length >= 10 ) {
        var mid = Math.floor( name.length / 2 );
        var bestDistance = name.length;
        var bestIndex = -1;

        for( var i = 0; i < name.length; ++i ) {
            var distance = Math.abs(mid-i);
            if( name[i] == ' ' && distance < bestDistance ) {
                bestIndex = i;
                bestDistance = distance;
            }
        }

        if( bestIndex >= 0 ) {
            // Split the name into two.
            arr.push( {text:myTrim( name.substring( 0, bestIndex ) )} );
            arr.push( {text:myTrim( name.substring( bestIndex, name.length ) )} );
            return arr;
        }

    }

    arr.push( {text:myTrim(name)} );
    return arr;
}

function colorFromID( id ) {
    return "#" + $(id).value;
}

function createSeatingArrangement() {
    var memberAngle = g_Origin.memberStartAngle;
    var step = 360 / g_Members.length;
    var masterAngle = memberAngle - step/2;
    var radiusStep = 1;
    var memberRadius = g_Origin.torusRingSize 
                     + g_Origin.torusRingSpacing
                     + g_Origin.memberSpacing + 1;
    var masterRadius = g_Origin.torusRingSize + g_Origin.torusRingMasterSpacing;
    var titleRadius = masterRadius + g_Origin.titleSpacing;
    var maxRadius = g_Origin.imageCenterY;
    var obj;
    var result = "";
    var context = $("_canvas").getContext("2d");

    if( $("or").value === "counter" ) {
        step = -step;
    }

    // Create the center object.
    obj = createTextObject( OBJECT_TYPE.RECIPIENT,
                            massageName( $("rep").value ),
                            $("_canvas"), 
                            context,
                            g_RecipientFontDesc, 
                            ALIGNMENT.CENTER, 
                            g_Origin, 
                            0,      // radius
                            0,      // angle
                            g_Origin.torusRingSpacing );
    obj.setBoundingRadius( g_Origin.torusRingSize );
    g_ObjectArray.push( obj );

    // Create the member objects
    for( var i = 0; i < g_Members.length; ++i ) {
        obj = createTextObject( OBJECT_TYPE.MEMBER,
                                massageName( g_Members[i].member ),
                                $("_canvas"), 
                                context,
                                g_MemberFontDesc, 
                                ALIGNMENT.AUTO, 
                                g_Origin, 
                                memberRadius,
                                memberAngle,
                                g_Origin.memberSpacing );
        g_ObjectArray.push( obj );
        memberAngle += step;

        // Attempt to place the member.
        for( var r = memberRadius; r < maxRadius; r += radiusStep ) {
            obj.setRadius( r );
            result = testOverlap();
            if( result == null ) {
                break;
            }
        }

        if( result != null ) {
            // Return the member placement error.
            return result;
        }
    }

    // Create the master objects
    for( var i = 0; i < g_Members.length; ++i ) {
        if( g_Members[i].master !== "" ) {
            obj = createTextObject( OBJECT_TYPE.MASTER,
                                    massageName( g_Members[i].master ),
                                    $("_canvas"), 
                                    context,
                                    g_MasterFontDesc, 
                                    ALIGNMENT.AUTO, 
                                    g_Origin, 
                                    masterRadius,
                                    masterAngle,
                                    g_Origin.masterSpacing );
            g_ObjectArray.push( obj );

            // Attempt to place the master.
            for( var r = masterRadius; r < maxRadius; r += radiusStep ) {
                obj.setRadius( r );
                result = testOverlap();
                if( result == null ) {
                    break;
                }
            }

            if( result != null ) {
                // Return the master placement error.
                return result;
            }
        }
        masterAngle += step;
    }

    // Create the title object.
    var title = [];
    for( var i = 0; i < g_Title.length; ++i ) {
        title.push( {text:myTrim(g_Title[i]),
                     color:colorFromID(g_TitleFontDesc.textColorID)} );
    }
    if( $("tp").value !== "" ) {
        title.push( {text:myTrim($("tp").value), 
                     color:colorFromID(g_TitleFontDesc.titleGroupColorID)} );
    }

    obj = createTextObject( OBJECT_TYPE.TITLE,
                            title,
                            $("_canvas"), 
                            context,
                            g_TitleFontDesc, 
                            ALIGNMENT.CENTER, 
                            g_Origin, 
                            titleRadius,
                            270,                    // angle
                            g_Origin.titleSpacing  );
    g_ObjectArray.push( obj );

    // Attempt to place the title.
    for( var r = titleRadius; r < maxRadius; r += radiusStep ) {
        obj.setRadius( r );
        result = testOverlap();
        if( result == null ) {
            break;
        } 
    }

    return result;
}

function drawHeart( context, xCenter, yCenter, size, borderColour, innerColour ) {
    var x = xCenter-(size/2);
    var y = yCenter-(size/2);
    var w = size, h = size;
    var d = Math.min(w,h);
    context.strokeStyle = borderColour;
    context.strokeWeight = 3;
    context.shadowOffsetX = 4.0;
    context.shadowOffsetY = 4.0;
    context.lineWidth = size < 20 ? 1 : 5;
    context.beginPath();
    context.moveTo( x, y+d/4 );
    context.quadraticCurveTo( x,y, x+d/4, y);
    context.quadraticCurveTo( x+d/2, y, x+d/2, y+d/4 );
    context.quadraticCurveTo( x+d/2, y, x+d*3/4, y );
    context.quadraticCurveTo( x+d, y, x+d, y+d/4 );
    context.quadraticCurveTo( x+d, y+d/2, x+d*3/4, y+d*3/4 );
    context.lineTo( x+d/2, y+d );
    context.lineTo( x+d/4, y+d*3/4 );
    context.quadraticCurveTo( x, y+d/2, x, y+d/4 );
    if( innerColour != undefined ) {
        context.fillStyle = innerColour;
        context.fill();
    }
    context.closePath();
    context.stroke();
}

function drawPeg( context, x, y ) {
    var colour = colorFromID(g_RecipientFontDesc.torusPegColorID);
    var borderColour = colorFromID(g_RecipientFontDesc.torusPegBorderColorID);
    var pegSize = g_Origin.torusRingPegSize;

    if( g_PegTreatment == PEG_TREATMENT.CIRCLE ) {
        context.strokeStyle = borderColour;
        context.lineWidth = 1;
        context.beginPath();
        context.arc( x, y, pegSize, 0, 2*Math.PI );
        context.fillStyle = colour;
        context.fill();
        context.closePath();
        context.stroke();
    } else if( g_PegTreatment == PEG_TREATMENT.SQUARE ) {
        context.strokeStyle = borderColour;
        context.lineWidth = 1;
        context.beginPath();
        context.moveTo( x-pegSize, y-pegSize );
        context.lineTo( x+pegSize, y-pegSize );
        context.lineTo( x+pegSize, y+pegSize );
        context.lineTo( x-pegSize, y+pegSize );
        context.fillStyle = colour;
        context.fill();
        context.closePath();
        context.stroke();
    } else if( g_PegTreatment == PEG_TREATMENT.DIAMOND ) {
        context.strokeStyle = borderColour;
        context.lineWidth = 1;
        context.beginPath();
        context.moveTo( x, y-pegSize );
        context.lineTo( x+pegSize, y );
        context.lineTo( x, y+pegSize );
        context.lineTo( x-pegSize, y );
        context.fillStyle = colour;
        context.fill();
        context.closePath();
        context.stroke();
    } else if( g_PegTreatment == PEG_TREATMENT.HEART ) {
        drawHeart( context, x, y, pegSize*2, borderColour, colour );
    }
}

function iterateSacred( obj, radius, x, y, centerArray ) {
    var d = distance( x, y, 0, 0 );
    var visible = d <= obj.boundingRadius;
    if( d <= obj.boundingRadius + radius ) {
        for( var i = 0; i < centerArray.length; ++i ) {
            if( Math.abs( centerArray[i].centerX - x ) < 2
             && Math.abs( centerArray[i].centerY - y ) < 2 ) {
                // The point is already added
                return visible;
            }
        }

        var myIndex = centerArray.length;
        centerArray.push( {centerX:x, centerY:y} );

        var points = [];
        for( var angle = 0; angle < 360; angle+=60 ) {
            var newX = x + radius * Math.cos( angle * Math.PI / 180 );
            var newY = y + radius * Math.sin( angle * Math.PI / 180 );
            points[angle/60] = iterateSacred( obj, radius, newX, newY, centerArray );
        }

        centerArray[myIndex].visiblePoints = points;
        return visible;
    }
    return false;
}

function drawSeatingArrangement() {
    var     minX = maxX = g_Origin.imageCenterX;
    var     minY = maxY = g_Origin.imageCenterY;

    // Restore the canvas to configured dimensions.
    $("_canvas").width = g_Origin.imageWidth;
    $("_canvas").height = g_Origin.imageHeight;
    
    // Compute the image dimensions for cropping.
    if( g_ObjectArray.length > 0 ) {
        var obj = g_ObjectArray[0];
        var maxRadius = obj.origin.torusRingSize + obj.spacing;

        minX = Math.min( minX, obj.centerX() - maxRadius );
        maxX = Math.max( maxX, obj.centerX() + maxRadius );

        minY = Math.min( minY, obj.centerY() - maxRadius );
        maxY = Math.max( maxY, obj.centerY() + maxRadius );

        for( var i = 0; i < g_ObjectArray.length; ++i ) {
            var obj = g_ObjectArray[i];

            minX = Math.min( minX, obj.left() );
            maxX = Math.max( maxX, obj.right() );

            minY = Math.min( minY, obj.top() );
            maxY = Math.max( maxY, obj.bottom() );
        }
    }

    minX = Math.max( minX - g_Origin.cropSpacing, 0 );
    minY = Math.max( minY - g_Origin.cropSpacing, 0 );

    maxX = Math.min( maxX + g_Origin.cropSpacing, g_Origin.imageWidth );
    maxY = Math.min( maxY + g_Origin.cropSpacing, g_Origin.imageHeight );

    // Resize and fill the canvas
    var newWidth = maxX-minX;
    var newHeight = maxY-minY;
    $("_canvas").width = newWidth;
    $("_canvas").height = newHeight;
    
    // Alter the image 'center' before the redraw.
    g_Origin.setImageCenter( g_ObjectArray[0].centerX() - minX,
                             g_ObjectArray[0].centerY() - minY );

    // Draw all the objects.
    for( var i = 0; i < g_ObjectArray.length; ++i ) {
        var obj     = g_ObjectArray[i];

        context = obj.context;
        if( i == 0 ) {
            pegs = [];

            context.fillStyle = g_RecipientFontDesc.imageColor;
            context.fillRect( 0, 0, newWidth, newHeight );

            // Compute all the peg locations
            for( var j = 0; j < g_ObjectArray.length; ++j ) {
                var pegObj = g_ObjectArray[j];

                if( pegObj.objectType == OBJECT_TYPE.MEMBER ) {
                    var peg = pegObj.origin.polarToAbsXY( obj.boundingRadius, pegObj.angle );
                    pegs.push( peg );
                }
            }

            switch( g_TorusTreament ) {
                case TORUS_TREATMENT.MESH:
                    for( j =0; j < pegs.length; ++j ) {
                        for( var k = j+1; k < pegs.length; ++k ) {
                            context.strokeStyle = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);
                            context.lineWidth = 1;
                            context.beginPath();
                            context.moveTo( pegs[j].x, pegs[j].y );
                            context.lineTo( pegs[k].x, pegs[k].y );
                            context.closePath();
                            context.stroke();
                        }
                    }
                    break;
	
                case TORUS_TREATMENT.IMAGE:
                    if( g_TorusImage != undefined && g_TorusImage.complete ) {
                        var width = g_TorusImage.width;
                        var height = g_TorusImage.height;
                        var scale = 2 * obj.boundingRadius / Math.sqrt( width*width + height*height );
                        var newWidth = Math.floor( scale * width );
                        var newHeight = Math.floor( scale * height );
                        
                        context.drawImage( g_TorusImage,
                                           obj.centerX() - newWidth/2,
                                           obj.centerY() - newHeight/2,
                                           newWidth,
                                           newHeight );
                    }
                    break;

                case TORUS_TREATMENT.HEART:
                    drawHeart( context, obj.centerX(), obj.centerY(), obj.boundingRadius, 
                                colorFromID(g_RecipientFontDesc.torusTreatmentColorID) );
                    break;

                case TORUS_TREATMENT.RANDOM:
                    {
                        var startColour = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);
                        var rnd = new myRand( computeSeed() );

                        function polarToXY( radius, angle ) {
                            if( radius == null ) {
                                radius = rnd.nextRange( 0, obj.boundingRadius );
                            }
                            if( angle == null ) {
                                angle = rnd.nextRange( 0, 360 );
                            } 
                            return { x:radius * Math.cos( angle * Math.PI / 180 ),
                                     y:radius * Math.sin( angle * Math.PI / 180 ),
                                     radius:radius,
                                     angle:angle };
                        }

                        context.save();
                        context.beginPath();
                        context.arc( obj.centerX(), obj.centerY(), 
                                     obj.boundingRadius + 1, 0, 2*Math.PI );
                        context.clip();


                        context.translate( obj.centerX(), obj.centerY() );
                        context.lineJoin = "round";

                        var startAngle = rnd.nextRange( 0, 360 );
                        var steps = rnd.nextRange( 5, 16 );
                        var increment = 360 / steps;
                        var points = [ {x:0, y:0},          // origin
                                       polarToXY( obj.boundingRadius, startAngle ),
                                       polarToXY( obj.boundingRadius, startAngle + increment ), 
                                       polarToXY( obj.boundingRadius/2, startAngle ),
                                       polarToXY( obj.boundingRadius/2, startAngle + increment ), 
                                       polarToXY( obj.boundingRadius/2, startAngle + (increment/2) ),
                                       polarToXY( obj.boundingRadius, startAngle + increment*2 ),
                                       polarToXY( obj.boundingRadius, startAngle - increment*2 ),
                                       polarToXY( obj.boundingRadius/2, startAngle + increment*2 ),
                                       polarToXY( obj.boundingRadius/2, startAngle - increment*2 ),
                                     ];
                                        
                        var count = rnd.nextRange( 5, 10 );
                        var randPoints = [];
                        var STYLE = { POSITION:0, LINE:1, BEZIER:2, CIRCLE:3, MAX_STYLES:4 };
                        for( var j = 0; j < count; ++j ) {
                            var style = (j==0) ? STYLE.POSITION : rnd.nextRange( STYLE.LINE, STYLE.MAX_STYLES );
                            var point = points[rnd.nextRange( 0, points.length )];
                            var dot = rnd.nextRange( 0, 5 ) == 3;
                            var lum = distance(point.x, point.y, 0, 0) / obj.boundingRadius;
                            lum *= rnd.nextRange( -10, 10 ) / 5;
                            var colour = randomColour( startColour, 
                                                       [lum,
                                                        lum,
                                                        lum] );

                            if( style == STYLE.BEZIER ) {
                                randPoints.push( {style:STYLE.BEZIER,
                                                  point:point,
                                                  control1:points[rnd.nextRange( 0, points.length )],
                                                  control2:points[rnd.nextRange( 0, points.length )],
                                                  dot:dot,
                                                  colour:colour} );
                            } else if( style == STYLE.CIRCLE ) {
                                randPoints.push( {style:style,
                                                  point:point,
                                                  dot:false,
                                                  radius:rnd.nextRange( 10, obj.boundingRadius/2 ),
                                                  colour:colour} );
                            } else {
                                randPoints.push( {style:style,
                                                  point:point,
                                                  dot:dot,
                                                  colour:colour} );
                            }
                        }

                        context.strokeStyle = colour;
                        context.lineWidth = 1;
                        for( var j = 0; j < steps; ++j ) {
                            var cursor, oldCursor;
                            var dot = false;
                            for( var k = 0; k < randPoints.length; ++k ) {
                                var rp = randPoints[k];
                                switch( rp.style ) {
                                    case STYLE.POSITION:
                                        cursor = rp;
                                        break;

                                    case STYLE.LINE:
                                        context.strokeStyle = rp.colour;
                                        context.beginPath();
                                        context.moveTo( cursor.x, cursor.y );
                                        cursor = rp.point;
                                        context.lineTo( cursor.x, cursor.y );
                                        context.closePath();
                                        context.stroke();
                                        break;

                                    case STYLE.CIRCLE:
                                        context.strokeStyle = rp.colour;
                                        context.beginPath();
                                        context.arc( rp.point.x, rp.point.y, rp.radius, 0, 2*Math.PI );
                                        context.closePath();
                                        context.stroke();
                                        break;

                                    case STYLE.BEZIER:
                                        context.strokeStyle = rp.colour;
                                        context.beginPath();
                                        context.moveTo( cursor.x, cursor.y );
                                        context.bezierCurveTo( rp.control1.x, rp.control1.y,
                                                               rp.control2.x, rp.control2.y,
                                                               rp.point.x, rp.point.y );
                                        cursor = rp.point;
                                        context.closePath();
                                        context.stroke();
                                        break;
                                }

                                if( dot ) {
                                    context.beginPath();
                                    context.arc( oldCursor.x, oldCursor.y, 5, 0, 2*Math.PI );
                                    context.fillStyle = colour;
                                    context.fill();
                                    context.closePath();
                                    context.stroke();
                                }

                                dot = rp.dot;
                                oldCursor = cursor;
                            }
                            context.rotate( increment * Math.PI/180 );
                        }

                        context.restore();
                    }
                    break;

                case TORUS_TREATMENT.GEOMETRIC_1:
                    {
                        for( var j = 0; j < g_ObjectArray.length; ++j ) {
                            var pegObj = g_ObjectArray[j];

                            if( pegObj.objectType == OBJECT_TYPE.MEMBER ) {
                                var pointA;

                                context.strokeStyle = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);
                                context.lineWidth = 1;
                                context.beginPath();
                                point = pegObj.origin.polarToAbsXY( obj.boundingRadius, pegObj.angle );
                                context.moveTo( point.x, point.y );
                                point = pegObj.origin.polarToAbsXY( obj.boundingRadius, pegObj.angle+120 );
                                context.lineTo( point.x, point.y );
                                point = pegObj.origin.polarToAbsXY( obj.boundingRadius, pegObj.angle+240 );
                                context.lineTo( point.x, point.y );
                                context.closePath();
                                context.stroke();
                                
                                context.beginPath();
                                point = pegObj.origin.polarToAbsXY( obj.boundingRadius/2, pegObj.angle+60 );
                                context.arc( point.x, point.y, obj.boundingRadius/2, 0, 2*Math.PI );
                                context.closePath();
                                context.stroke();

                                context.beginPath();
                                point = pegObj.origin.polarToAbsXY( obj.boundingRadius/2, pegObj.angle+180 );
                                context.arc( point.x, point.y, obj.boundingRadius/2, 0, 2*Math.PI );
                                context.closePath();
                                context.stroke();

                                context.beginPath();
                                point = pegObj.origin.polarToAbsXY( obj.boundingRadius/2, pegObj.angle-60 );
                                context.arc( point.x, point.y, obj.boundingRadius/2, 0, 2*Math.PI );
                                context.closePath();
                                context.stroke();
                            }
                        }
                    }
                    break;

                case TORUS_TREATMENT.FLOWER_OF_LIFE:
                    {
                        var centerArray = [];
                        var radius = Math.floor( obj.boundingRadius/3 );
                        var startColour = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);

                        iterateSacred( obj, radius, 0, 0, centerArray );
                        context.lineWidth = 1;
                        context.strokeStyle = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);
                        for( var j = 0; j < centerArray.length; ++j ) {
                            var point = obj.origin.absXY( centerArray[j].centerX, centerArray[j].centerY );

                            context.strokeStyle = pointColour( obj, point, startColour );
                            var visiblePoints = centerArray[j].visiblePoints;
                            for( var k = 0; k < visiblePoints.length; ++k ) {
                                var endIndex = (k+1) % visiblePoints.length;
                                if( visiblePoints[k] && visiblePoints[endIndex] ) {
                                    var startAngle = 2*Math.PI * k / visiblePoints.length;
                                    var endAngle = 2*Math.PI * endIndex / visiblePoints.length;
                                    context.beginPath();
                                    context.arc( point.x, point.y, radius, startAngle, endAngle );
                                    context.closePath();
                                    context.stroke();
                                }
                            }
                        }
                    }
                    break;

                case TORUS_TREATMENT.METATRONS_CUBE:
                    {
                        var radius = obj.boundingRadius/5;
                        var points = [];
                        var startColour = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);
                        var angleStep = 360 / 6;

                        points.push( {point:pegObj.origin.polarToAbsXY( 0, 0 ), colour:startColour} );
                        for( var r = 2*radius; r <= 4*radius; r += 2*radius ) {
                            for( var count = 0; count < 6; ++count ) {
                                var point = pegObj.origin.polarToAbsXY( radius, 90+count*angleStep );
                                points.push( {point:pegObj.origin.polarToAbsXY( r, 90+count*angleStep ), 
                                              colour:pointColour( obj, point, startColour )} );
                            }
                        }

                        context.lineWidth = 1;
                        for( var j = 0; j < points.length; ++j ) {
                            context.strokeStyle = points[j].colour;
                            context.beginPath();
                            context.arc( points[j].point.x, points[j].point.y, radius, 0, 2*Math.PI );
                            context.closePath();
                            context.stroke();
                        }

                        for( var j = 1; j < points.length; ++j ) {
                            for( var k = j+1; k < points.length; ++k ) {
                                var gradient = context.createLinearGradient( points[j].point.x, points[j].point.y,
                                                                             points[k].point.x, points[k].point.y );
                                gradient.addColorStop( 0, points[j].colour );
                                gradient.addColorStop( 1, points[k].colour );
                                context.strokeStyle = gradient;
                                context.beginPath();
                                context.moveTo( points[j].point.x, points[j].point.y );
                                context.lineTo( points[k].point.x, points[k].point.y );
                                context.closePath();
                                context.stroke();
                                context.fillStyle = null;
                            }
                        }
                    }
                    break;

                case TORUS_TREATMENT.DAISY:
                    {
                        var startColour = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);
                        var width = obj.boundingRadius / 6;
                         
                        for( var radius = width/2; radius < obj.boundingRadius; radius += width/2 ) {
                            for( var angle = 0; angle < 360; angle += 10 ) {
                                var center = obj.origin.polarToAbsXY( radius, angle );
                                var colour = pointColour( obj, center, startColour );
                                context.beginPath();
                                context.strokeStyle = colour;
                                context.arc( center.x, center.y, width/2, 0, 2*Math.PI );
                                context.closePath();
                                context.stroke();
                            }
                            width *= 2;
                        }
                    }
                    break;

                case TORUS_TREATMENT.PETALS:
                    {
                        var startColour = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);
                        for( var angle=0; angle < 360; angle+=20 ) {
                            var center = obj.origin.polarToAbsXY( obj.boundingRadius/2, angle );
                            context.beginPath();
                            context.strokeStyle = pointColour( obj, center, startColour );
                            context.ellipse( center.x, center.y, obj.boundingRadius/2, 20, 
                                             angle * Math.PI / 180, 2*Math.PI, false );
                            context.fillStyle = pointColour( obj, center, startColour, "rgba", 0.1 );
                            context.fill();
                            context.closePath();
                            context.stroke();
                        }
                    }
                    break;
            }

            // Draw the torus
            obj.drawCircle( colorFromID(obj.fontDesc.torusColorID), 
                            parseInt( $("torw").value ), 0 );

            // Draw the pegs
            for( var j = 0; j < pegs.length; ++j ) {
                drawPeg( context, pegs[j].x, pegs[j].y );
            }
        } else {
            if( g_Debug ) {
                obj.debugBoundingBox( obj.spacing );
            }
        }

        obj.draw();

        if( g_Debug ) {
            obj.drawCircle( obj.fontDesc.DebugColor, 1, 0 );
            obj.drawCircle( obj.fontDesc.DebugColor, 1, obj.spacing );

            obj.debugBoundingBox( 0 );
        }
    }
}

function pointColour( torusObj, point, startColour, method, opacity ) {
    var radius = torusObj.boundingRadius * 0.75;
    var p0 = torusObj.origin.polarToAbsXY( radius, 30 );
    var p1 = torusObj.origin.polarToAbsXY( radius, 150 );
    var p2 = torusObj.origin.polarToAbsXY( radius, 270 );
    var maxDistance = distancePoints(p0, p1);
    var arr = [Math.min( distancePoints(point, p0), maxDistance ),
               Math.min( distancePoints(point, p1), maxDistance ), 
               Math.min( distancePoints(point, p2), maxDistance )];
    var magnitude = arr[0] + arr[1] + arr[2];
    var percent = [ arr[0]/magnitude, 
                    arr[1]/magnitude,
                    arr[2]/magnitude ];

	// validate hex string
	var hex = String(startColour).replace(/[^0-9a-f]/gi, '');
	if (hex.length < 6) {
		hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
	}

	// convert to decimal and change luminosity
    if( method != null ) {
        rgb = method + "(";
    } else {
        // hexadecimal color
        var rgb = "#", c, i;
    }
	for (i = 0; i < 3; i++) {
		c = parseInt(hex.substr(i*2,2), 16);
        
        c = c + 2*256*(0.5-percent[i]);
		c = Math.round(Math.min(Math.max(0, c), 255));
        if( method != null ) {
            rgb += c.toString();
            if( i < 2 ) {
                rgb += ",";
            }
        } else {
            c = c.toString(16);
            rgb += ("00"+c).substr(c.length);
        }
	}
    if( method != null ) {
        if( opacity != null ) {
            rgb += "," + opacity.toString();
        }
        rgb += ")";
    }

	return rgb;
}

function randomColour(hex, lumArray) {
	// validate hex string
	hex = String(hex).replace(/[^0-9a-f]/gi, '');
	if (hex.length < 6) {
		hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
	}

	// convert to decimal and change luminosity
	var rgb = "#", c, i;
	for (i = 0; i < 3; i++) {
		c = parseInt(hex.substr(i*2,2), 16);
        c = c + (c*lumArray[i]);
		c = Math.round(Math.min(Math.max(0, c), 255)).toString(16);
		rgb += ("00"+c).substr(c.length);
	}

	return rgb;
}

function colorLuminance(hex, lum) {
	// validate hex string
	hex = String(hex).replace(/[^0-9a-f]/gi, '');
	if (hex.length < 6) {
		hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
	}
	lum = lum || 0;

	// convert to decimal and change luminosity
	var rgb = "#", c, i;
	for (i = 0; i < 3; i++) {
		c = parseInt(hex.substr(i*2,2), 16);
		c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
		rgb += ("00"+c).substr(c.length);
	}

	return rgb;
}

function lastVisibleMember() {
    var lastVisible = g_Origin.maxMembers - 1;
    while( lastVisible >= 0 ) {
        if( $("p" + lastVisible).value !== "" ) {
            break;
        }
        --lastVisible;
    }
    return lastVisible;
}

function buildCanvas() {
    resetGlobals();
    g_Debug = $("_debug").checked;

    g_RecipientFontDesc.imageColor = g_Debug ? "yellow" : colorFromID("bgc");

    g_TorusTreament = parseInt($("tort").value);
    g_PegTreatment = parseInt($("pegt").value);

    if( $("t1").value !== "" )   g_Title.push( $("t1").value );
    if( $("t2").value !== "" )   g_Title.push( $("t2").value );

    var lastVisible = lastVisibleMember();
    for( var i = 0; i < g_Origin.maxMembers; ++i ) {
        var member = $("p" + i).value;
        var master = $("m" + i).value;

        if( member !== "" ) {
            g_Members.push( {member:member, master:master} );
        }

        if( i <= lastVisible ) {
            $("tr" + i).style.visibility = "visible";
        } else {
            $("tr" + i).style.visibility = "hidden";
        }
    }

    setDefaultFilename();

    g_Origin.memberStartAngle = parseInt( $("o").value );
    g_Origin.torusRingSize = parseInt( $("tors").value );
    g_Origin.torusRingPegSize = parseInt( $("pegw").value );
    if( g_Origin.torusRingSize < 100 || g_Origin.torusRingSize > 300 ) {
        g_Origin.torusRingSize = 100;
    }
    var result = createSeatingArrangement();
    if( result == null ) {
        $("_error").innerHTML = "";
        drawSeatingArrangement();
    } else {
        $("_error").innerHTML = result;
    }

    composeMyURL();
}

function newImage() {
    g_TorusImage = new Image;
    g_TorusImage.crossOrigin = "Anonymous";
    g_TorusImage.onload = function() { buildCanvas(); }
    g_TorusImage.src = $("tori").value;

    // make sure the load event fires for cached images too
    if( g_TorusImage.complete || g_TorusImage.complete === undefined ) {
        g_TorusImage.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
        g_TorusImage.src = $("tori").value;
    }
}

function testCORS() {
    var testImage = new Image;
    testImage.src = "http://maps.gstatic.com/mapfiles/api-3/images/google_white5.png";
    testImage.onload = function() {
        var canvas = $("_testCanvas");
        var context = canvas.getContext("2d");
        context.drawImage( testImage, 0, 0, 10, 10 ); 
    
        // Cross-Origin Resource Sharing (CORS) is a W3C specification that
        //  allows cross-domain communication from the browser.  Note that
        //  often cross-domain refers to resources that have different hostnames.
        //  When CORS isn't enabled, it prevents this program from including
        //  images to be embedded in the downloaded image (although they could
        //  still be rendered).  We'll detect this scenario and prevent images
        //  from being embedded.
        var violation = false;
        try {
            var junkHref = canvas.toDataURL("image/png");
        } catch( err ) {
            violation = true;
        }
        g_CORSEnabled = violation;
    }
}

function testOverlap() {
    for( var i = 1; i < g_ObjectArray.length; ++i ) {
        var obj = g_ObjectArray[i];

        if( obj.intersectsCircle( g_ObjectArray[0] ) ) {
            return "object '" + obj.getName() + "' intersects torus circle";
        }
    }
    
    for( var i = 0; i < g_ObjectArray.length; ++i ) {
        var obj = g_ObjectArray[i];
        if( obj.exceedsImageBoundary() ) {
            return "object '" + obj.getName() + "' exceeds image boundary";
        }

        for( var j = i+1; j < g_ObjectArray.length; ++j ) {
            var outerObj = g_ObjectArray[j];
            if( obj.intersectsBoundingBox( outerObj ) ) {
                return "object '" + obj.getName() + "' intersects with '" 
                        + outerObj.getName() + "'";
            }
        }
    }

    return null;    // no intersection
}

function distance( x1, y1, x2, y2 ) {
    return Math.sqrt( Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2) );
}

function distancePoints( p1, p2 ) {
    return distance( p1.x, p1.y, p2.x, p2.y );
}

function myTrim( str ) {
    return str.replace(/^\s+|\s+$/g,"");
}

function createTextObject( objectType,
                           textArray, 
                           canvas, 
                           context,
                           fontDesc, 
                           alignment, 
                           origin, 
                           radius, 
                           angle, 
                           spacing ) {
    var obj = {};
    obj.objectType = objectType;
    obj.textArray = textArray;
    obj.canvas = canvas;
    obj.fontDesc = fontDesc;
    obj.alignment = alignment;
    obj.origin = origin;
    obj.radius = radius;
    obj.angle = angle % 360;
    obj.spacing = spacing;

    obj.font = ($(fontDesc.fontItalicID).checked ? "italic" : "normal") + " "     // font style
             + ($(fontDesc.fontBoldID).checked ? "bold" : "normal") + " "         // font weight
             + $(fontDesc.fontSizeID).value + " " 
             + $(fontDesc.fontFamilyID).value;
    obj.shadowEnabled = $(fontDesc.fontShadowID).checked;
    obj.context = context;
    obj.context.font = obj.font;

    obj.line = [];
    var maxWidth = 0;
    for( var i = 0; i < textArray.length; ++i ) {
        var width = Math.round( obj.context.measureText( textArray[i].text ).width );
        obj.line.push( {'text':myTrim(textArray[i].text),
                        'width':width,
                        'color':textArray[i].color} );
        if( width > maxWidth ) maxWidth = width;
    }

    obj.fontHeight = parseInt($(fontDesc.fontSizeID).value);   // e.g. "14px"
    obj.boundingWidth = maxWidth;
    obj.boundingHeight = obj.fontHeight * textArray.length;

    obj.boxCenterX = Math.round( obj.boundingWidth / 2 );
    obj.boxCenterY = Math.round( obj.boundingHeight / 2 );
    obj.boundingRadius = distance( 0, 0, obj.boxCenterX, obj.boxCenterY );

    obj.adjustX = 0;
    obj.adjustY = 0;

    if( obj.objectType == OBJECT_TYPE.MEMBER ) {
        // Some fine placement is necessary for the member elements that
        //  immediately orbit the circle so that the member text is adjacent
        //  to the peg.
        var peg = obj.origin.polarToAbsXY( obj.origin.torusRingSize + obj.origin.torusRingPegSize,
                                           obj.angle ); 
        var center = obj.origin.polarToAbsXY( obj.radius, obj.angle );
        var top = center.y - obj.boxCenterY - obj.spacing;
        var bottom = top + obj.boundingHeight + obj.spacing;
        var left = center.x - obj.boxCenterX - obj.spacing;
        var right = left + obj.boundingWidth + obj.spacing;

        if( obj.angle == 0 || obj.angle == 90 || obj.angle == 180 || obj.angle == 270 ) {
            // this center is already correct
        } else if( obj.angle < 90 ) {
            // adjust to top left corner
            obj.adjustX = peg.x - left;
            obj.adjustY = peg.y - top;
        } else if( obj.angle < 180 ) {
            // adjust to top right corner
            obj.adjustX = peg.x - right;
            obj.adjustY = peg.y - top;
        } else if( obj.angle < 270 ) {
            // adjust to bottom right corner
            obj.adjustX = peg.x - right;
            obj.adjustY = peg.y - bottom;
        } else {
            // adjust to bottom left corner
            obj.adjustX = peg.x - left;
            obj.adjustY = peg.y - bottom;
        }
    }

    obj.toAbsXY = function() {
        var coord = this.origin.polarToAbsXY( this.radius, this.angle );
        coord.x += this.adjustX;
        coord.y += this.adjustY;
        return coord;
    };

    obj.centerX = function() {
        return this.toAbsXY().x;
    };

    obj.centerY = function() {
        return this.toAbsXY().y;
    };

    obj.left = function() {
        return this.centerX() - this.boxCenterX;
    };

    obj.top = function() {
        return this.centerY() - this.boxCenterY;
    };

    obj.right = function() {
        return this.left() + this.boundingWidth;
    };

    obj.bottom = function() {
        return this.top() + this.boundingHeight;
    };

    obj.setRadius = function( radius ) {
        this.radius = radius;
    };

    obj.setBoundingRadius = function( boundingRadius ) {
        this.boundingRadius = boundingRadius;
    };

    obj.getName = function() {
        var str = "";
        for( var i = 0; i < this.textArray.length; ++i ) {
            str = str + " " + this.textArray[i].text;
        }
        return myTrim(str);
    }

    obj.draw = function() {
        var center = this.toAbsXY();
        var y = center.y - ((this.line.length - 1)*this.fontHeight) / 2;
        this.context.textBaseline = "middle";
        for( var i = 0; i < this.line.length; ++i ) {
            var line = this.line[i];
            var x;
            if( this.alignment == ALIGNMENT.LEFT ) {
                this.context.textAlign = "left";
                x = center.x - this.boxCenterX;
            } else if( this.alignment == ALIGNMENT.CENTER ) {
                this.context.textAlign = "center";
                x = center.x;
            } else if( this.alignment == ALIGNMENT.RIGHT ) {
                this.context.textAlign = "right";
                x = center.x + this.boxCenterX;
            } else {    // assume ALIGNMENT.AUTO
                // Choose the text alignment based on the angle.
                if( angle <= 45 || angle >= 315 ) {
                    this.context.textAlign = "left";
                    x = center.x - this.boxCenterX;
                } else if( angle >= 135 && angle <= 225 ) {
                    this.context.textAlign = "right";
                    x = center.x + this.boxCenterX;
                } else {
                    this.context.textAlign = "center";
                    x = center.x;
                }
            }
            this.context.font = this.font;
            if( this.shadowEnabled ) {
                // Create a shadow effect for the text
                shadow = colorLuminance( this.line[i].color || colorFromID(this.fontDesc.textColorID),
                                         -0.1 ); 
                this.context.shadowColor = shadow;
                this.context.shadowBlur = 10;
                this.context.lineWidth = 1; 
                this.context.strokeText( this.line[i].text, x, y );
                this.context.shadowBlur = 0; 
            }
            this.context.fillStyle = this.line[i].color || colorFromID(this.fontDesc.textColorID);
            this.context.fillText( this.line[i].text, x, y );
            y = y + this.fontHeight;
        }
    };

    obj.drawCircle = function( color, width, spacing, fillColour ) {
        var context = this.context;

        context.fillStyle = fillColour;
        context.strokeStyle = color || this.fontDesc.debugColor;
        context.lineWidth = width;
        context.beginPath();
        context.arc( this.centerX(), this.centerY(), this.boundingRadius + spacing + 1, 0, 2*Math.PI );
        if( fillColour != undefined ) {
            context.fill();
        }
        context.closePath();
        context.stroke();
    };

    obj.debugBoundingBox = function( spacing ) {
        var context = this.context;
        context.strokeStyle = this.fontDesc.debugColor;
        context.lineWidth = 1;
        context.beginPath();
        context.moveTo( this.left()-spacing, this.top()-spacing );
        context.lineTo( this.right()+spacing, this.top()-spacing );
        context.lineTo( this.right()+spacing, this.bottom()+spacing );
        context.lineTo( this.left()-spacing, this.bottom()+spacing );
        context.closePath();
        context.stroke();
    };

    obj.exceedsImageBoundary = function() {
        return this.left() < 0
            || this.right() >= obj.origin.imageWidth
            || this.top() < 0
            || this.bottom() >= obj.origin.imageHeight;
    };

    obj.intersectsBoundingBox = function( obj ) {
        return (this.left()-this.spacing <= obj.right()+obj.spacing)
            && (obj.left()-obj.spacing   <= this.right()+this.spacing)
            && (this.top()-this.spacing  <= obj.bottom()+obj.spacing)
            && (obj.top()-obj.spacing    <= this.bottom()+this.spacing);
    };

    obj.distanceToXY = function( x, y ) {
        return distance( this.centerX(), this.centerY(), x, y );
    };

    obj.intersectsCircle = function( obj ) {
        var left = this.left()-this.spacing;
        var top = this.top()-this.spacing;
        var right = this.right()+this.spacing;
        var bottom = this.bottom()+this.spacing;
        var minRadius = obj.boundingRadius + this.spacing;
        var objCenterX = obj.centerX();
        var objCenterY = obj.centerY();

        // Check if any of the bounding corners (plus spacing) fall within
        //  the object's circle.
        if( obj.distanceToXY( left, top ) < minRadius
         || obj.distanceToXY( right, top ) < minRadius
         || obj.distanceToXY( right, bottom ) < minRadius
         || obj.distanceToXY( left, bottom ) < minRadius ) {
            return true;
        }

        // Check if the top/bottom of the bounding box intersects with
        //  the object's circle.
        if( left < objCenterX && right > objCenterX 
         && (Math.abs( top-objCenterY ) < minRadius
             || Math.abs( bottom-objCenterY ) < minRadius) ) {
            return true;
        }

        // Check if the left/right of the bounding box intersects with
        //  the object's circle.
        if( top < objCenterY && bottom > objCenterY
         && (Math.abs( left-objCenterX ) < minRadius
             || Math.abs( right-objCenterX ) < minRadius) ) {
            return true;
        }

        return false;
    };

    return obj;
}

function getNumberStringPrefix( num ) {
    // determine 'st', 'nd', or 'rd', or 'th' prefix
    if( num <= 20 ) {
        if( num == 1 ) {
            return "st";
        } else if( num == 2 ) {
            return "nd";
        } else if( num == 3 ) {
            return "rd";
        } else {
            return "th";
        }
    } else {
        num = num % 10;

        if( num == 1 ) {
            return "st";
        } else if( num == 2 ) {
            return "nd";
        } else if( num == 3 ) {
            return "rd";
        } else {
            return "th";
        }
    }
}

function getDateString() {
    var day = new Date();
    var monthNames = ["January", "February", "March", "April", "May", "June", 
                      "July", "August", "September", "October", "November", "December"];
    var currentMonth = day.getUTCMonth();
    var str = monthNames[day.getUTCMonth()] + " " + day.getUTCDate() + getNumberStringPrefix( day.getUTCDate() ) + "/";

    // advance to 'tomorrow'
    day.setTime( day.getTime() + 86400 * 1000 );

    if( currentMonth == day.getUTCMonth() ) {
        // In current month.
        return str + day.getUTCDate() + getNumberStringPrefix( day.getUTCDate() );
    } else {
        return str + monthNames[day.getUTCMonth()] + " " + day.getUTCDate() + getNumberStringPrefix( day.getUTCDate() );
    }
}

function setDefaultFilename() {
    var day = new Date();
    var shortMonthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

    // NOTE: This may be a bit annoying to create the default filename based on the group title.
    //       We'll see how it goes.
    $("f").value = $("t1").value + " - " + 
                   shortMonthNames[day.getMonth()] + " " + day.getDate() + ", " + day.getFullYear() + ".png";

}

function getProfiles() {
    var profiles = [];
    for( var i = 0; i < g_Origin.maxProfiles; ++i ) {
        var cookie = getCookie( "profile"+i );
        if( cookie != null ) {
            var url = new Url( "?" + cookie );
            profiles.push( url.query );
        }
    }
    return profiles;
}

function setProfiles() {
    var u = getUrlWithParameters();
    var profiles = getProfiles();
    var found = false;

    u.query["day"] = (new Date()).getDay();
    for( var i = 0; i < profiles.length; ++i ) {
        if( profiles[i]["t1"] === u.query["t1"] ) {
            // found the profiles with the same title. Update it
            //  and move it to the top of the list.
            profiles.splice( i, 1 );         // remove old object
            profiles.splice( 0, 0, u.query );   // insert replacement
            found = true;
            break;
        }
    }

    if( !found ) {
        // add the object to the start of the list
        profiles.unshift( u.query );
        // possibly remove the extra entry
        if( profiles.length >= g_Origin.maxProfiles ) {
            profiles.splice( g_Origin.maxProfiles, profiles.length );
        }
    }

    for( var i = 0; i < profiles.length && i < g_Origin.maxProfiles; ++i ) {
        setCookie( "profile"+i, profiles[i].toString(), g_Origin.maxCookieDays );
    }
}

function selectProfile() {
    var profiles = getProfiles();
    var num = parseInt($("profile").value);

    // Set default element values
    initializeElementsFromHash( g_ElementDefaults );

    // Set values to selected profile.
    if( num >= 0 && num < profiles.length ) {
        initializeElementsFromHash( profiles[num] );
    }

    buildCanvas();
}

function saveProfile() {
    setProfiles();
    createProfilesElement( "profiles" );
}

function createProfilesElement( parentID ) {
    var weekDays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var profiles = getProfiles();
    var current = $("t1").value;
    var str = "<select class=dropDown name=profile id=profile onChange='selectProfile()'>\n";
    str += "<option value='-1'>Default</option>\n";
    for( var i = 0; i < profiles.length; ++i ) {
        str += "<option value='" + i + "'";
        if( profiles[i]["t1"] === current ) {
            str += " selected";
        } 
        str += ">" + profiles[i]["t1"];
        var day = profiles[i]["day"];
        if( weekDays[day] != undefined ) {
            str += " ("+weekDays[day]+")";
        }
        str += "</option>\n";
    }
    str += "</select>";
    var element = document.createElement( "span" );
    element.innerHTML = str;

    var last = $(parentID).lastChild;
    if( last != null ) {
        $(parentID).removeChild( last );
    }
    $(parentID).appendChild( element );
}

function createFontSelectionElements( parentID, fontDesc ) {
    var fontWeights = [ "normal", "bold" ];
    var fontSizes = [ "10px", "12px", "14px", "16px", "18px" ];

    var fontStyles = [ "normal", "italic" ];

    // font family selection
    var element = document.createElement( "span" );
    var str = "<select class=dropDown name=fontFamily id='" + fontDesc.fontFamilyID + "' onchange='buildCanvas()'>\n";
    for( var i = 0; i < g_DetectedFonts.length; ++i ) {
        str += "<option value='" + g_DetectedFonts[i] + "'";
        str += ">" + g_DetectedFonts[i] + "</option>\n";
    }
    str += "</select> ";
    element.innerHTML = str;
    $(parentID).appendChild( element );

    // font size selection
    element = document.createElement( "span" );
    var str = "<select class=dropDown name=fontSize id='" + fontDesc.fontSizeID + "' onchange='buildCanvas()'>\n";
    for( var i = 0; i < fontSizes.length; ++i ) {
        str += "<option value='" + fontSizes[i] + "'";
        str += ">" + fontSizes[i] + "</option>\n";
    }
    str += "</select> ";
    element.innerHTML = str;
    $(parentID).appendChild( element );

    // font bold selection
    element = document.createElement( "span" );
    str = "<B>Bold</B><input type=checkbox id='" + fontDesc.fontBoldID + "' onchange='buildCanvas()'>\n";
    element.innerHTML = str;
    $(parentID).appendChild( element );

    // font italic selection
    element = document.createElement( "span" );
    str = "<I>Italic</I><input type=checkbox id='" + fontDesc.fontItalicID + "' onchange='buildCanvas()'>\n";
    element.innerHTML = str;
    $(parentID).appendChild( element );

    // font shadow selection
    element = document.createElement( "span" );
    str = "<U>Shadow</U><input type=checkbox id='" + fontDesc.fontShadowID + "' onchange='buildCanvas()'>\n";
    element.innerHTML = str;
    $(parentID).appendChild( element );
}

function initializeElementsFromHash( hash ) {
    var all = document.getElementsByTagName("*");
    for( var i = 0; i < all.length; ++i ) {
        var el = all[i];
        if( hash[el.id] != undefined ) {
            var defaultValue = hash[el.id];

            if( el.nodeName === "SELECT" ) {
                el.value = defaultValue;
            } else if( el.nodeName === "INPUT" ) {
                if( el.type.toLowerCase() === "checkbox" ) {
                    el.checked = (defaultValue === "true");
                } else if( el.type.toLowerCase()==="select-one" ) {
                    el.value = defaultValue;
                } else if( el.type.toLowerCase()==="text") {
                    el.value = defaultValue;

                    // For jscolor class elements, update the text box background color.
                    if( el.className === "jscolor" ) {
                        // jscolor class element
                        el.jscolor.importColor();
                    }
                }
            }
        }
    }
}

function setParametersFromUrl( url ) {
    var u = new Url( url );

    initializeElementsFromHash( u.query );
}

function getUrlWithParameters() {
    var url = new Url();
    var all = document.getElementsByTagName("*");
    var hash = g_ElementDefaults;

    url.clearQuery();   // remove all query string parameters
    for( var i = 0; i < all.length; ++i ) {
        var el = all[i];

        if( hash[el.id] != undefined ) {
            var defaultValue = hash[el.id];

            if( el.nodeName === "SELECT" ) {
                if( el.value !== defaultValue ) {
                    url.query[el.id] = el.value;
                }
            } else if( el.nodeName === "INPUT" ) {
                if( el.type.toLowerCase() === "checkbox" ) {
                    if( el.checked != defaultValue ) {
                        url.query[el.id] = el.checked;
                    }
                } else if( el.type.toLowerCase()==="select-one"
                        || el.type.toLowerCase()==="text" ) {
                    if( el.value !== defaultValue ) {
                        url.query[el.id] = el.value;
                    }
                }
            }
        }
    }
    return url;
}

function composeMyURL() {
    var url = getUrlWithParameters();
    $("_myURL").innerHTML = "<b>" + url + "</b>";
}

function setCookie( name, value, days ) {
    var expires = "";
    if (days) {
        var date = new Date();
        date.setTime(date.getTime() + (days*24*60*60*1000));
        expires = "; expires=" + date.toUTCString();
    }
    document.cookie = name + "=" + (value || "")  + expires + "; path=/";
}

function getCookie( name ) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for(var i=0;i < ca.length;i++) {
        var c = ca[i];
        while (c.charAt(0)==' ') c = c.substring(1,c.length);
        if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
    }
    return null;
}

function eraseCookie( name ) {   
    document.cookie = name+'=; Max-Age=-99999999;';  
}

function deleteRow( num ) {
    if( num <= lastVisibleMember() ) {
        while( num < g_Origin.maxMembers-1 ) {
            $("p"+num).value = $("p"+(num+1)).value;
            $("m"+num).value = $("m"+(num+1)).value;
            ++num;
        }
        $("p"+num).value = "";
        $("m"+num).value = "";
        buildCanvas();
    }
}

function memberHandleDragStart(e) {
    this.style.opacity = '0.4';  // this / e.target is the source node.
    g_DragSrcEl = this;

    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData( "text/html", this.innerHTML);
}

function memberHandleDragOver(e) {
    if (e.preventDefault) {
        e.preventDefault(); // Necessary. Allows us to drop.
    }

    e.dataTransfer.dropEffect = 'move';  // See the section on the DataTransfer object.
    return false;
}

function memberHandleDragEnter(e) {
    // this / e.target is the current hover target.
    this.classList.add('over');
}

function memberHandleDragLeave(e) {
    this.classList.remove('over');  // this / e.target is previous target element.
}

function memberHandleDrop(e) {
    // this / e.target is current target element.

    if (e.stopPropagation) {
        e.stopPropagation(); // stops the browser from redirecting.
    }

    if( g_DragSrcEl != this ) {
        var srcRow = parseInt( g_DragSrcEl.id );
        var destRow = parseInt( this.id );
        var tempName = $("p"+srcRow).value;
        var tempMaster = $("m"+srcRow).value;

        if( destRow > srcRow ) {
            while( srcRow < destRow ) {
                $("p"+srcRow).value = $("p"+(srcRow+1)).value;
                $("m"+srcRow).value = $("m"+(srcRow+1)).value;
                ++srcRow;
            }
            $("p"+srcRow).value = tempName;
            $("m"+srcRow).value = tempMaster;
        } else {
            while( srcRow > destRow ) {
                $("p"+srcRow).value = $("p"+(srcRow-1)).value;
                $("m"+srcRow).value = $("m"+(srcRow-1)).value;
                --srcRow;
            }
        }
        $("p"+srcRow).value = tempName;
        $("m"+srcRow).value = tempMaster;
        buildCanvas();
    }

    var rows = document.querySelectorAll('#members .row');
    [].forEach.call(rows, function (row) {
        row.classList.remove('over');
        row.style.opacity = "";
    });

    return false;
}

function memberHandleDragEnd(e) {
    // this/e.target is the source node.

    var rows = document.querySelectorAll('#members .row');
    [].forEach.call(rows, function (row) {
        row.classList.remove('over');
        row.style.opacity = "";
    });
}

function imageHandleDrop(e) {
    // this / e.target is current target element.

    if (e.preventDefault) {
        e.preventDefault(); // Necessary. Allows us to drop.
    }

    if (e.stopPropagation) {
        e.stopPropagation(); // stops the browser from redirecting.
    }

    var url = e.dataTransfer.getData( "URL" );
    if( url ) {
        // If an image is being drag-and-drop'd then set the image treatment immediately.
        $("tori").value = url;
        $("tort").value = TORUS_TREATMENT.IMAGE;
        newImage();
    }
    return false;
}

function cancel(e) {
    if (e.preventDefault) {
        e.preventDefault(); // Necessary. Allows us to drop.
    }
    return false;
}

function addEventHandler(obj, evt, handler) {
    if(obj.addEventListener) {
        // W3C method
        obj.addEventListener(evt, handler, false);
    } else if(obj.attachEvent) {
        // IE method.
        obj.attachEvent('on'+evt, handler);
    } else {
        // Old school method.
        obj['on'+evt] = handler;
    }
}

function saveMembers() {
    for( var i = 0; i < g_Origin.maxMembers; ++i ) {
        var member = $("p" + i).value;
        if( member !== "" ) {
            var found = false;

            for( var j = 0; j < g_AllMembers.length; ++j ) {
                if( member === g_AllMembers[j] ) {
                    // Found the member in the list.  Update it and move
                    //  it to the top of the list.
                    g_AllMembers.splice( j, 1 );            // remove the old entry
                    g_AllMembers.splice( 0, 0, member );    // insert replacement
                    found = true;
                    break;
                }
            }

            if( !found ) {
                // Add the member to the start of the list.
                g_AllMembers.unshift( member );
                if( g_AllMembers.length >= g_Origin.maxDropDownMembers ) {
                    g_AllMembers.splice( g_Origin.maxDropDownMembers,
                                         g_Origin.length );
                }
            }
        }
    }
    setCookie( "membersList", g_AllMembers.join( "/" ) );
}

function loadMembers() {
    var cookie = getCookie( "membersList" );

    if( cookie == null ) {
        g_AllMembers = [];
    } else {
        g_AllMembers = cookie.split( "/" );
    }

    var element = document.createElement( "datalist" );
    var str = "";
    element.setAttribute( "id", "membersList" );
    for( var i = 0; i < g_AllMembers.length; ++i ) {
        str += "<option value='" + g_AllMembers[i] + "'>\n";
    }
    element.innerHTML = str;

    var last = $("membersDatalist").lastChild;
    if( last != null ) {
        $("membersDatalist").removeChild( last );
    }
    $("membersDatalist").appendChild( element );
}

function pageSetup() {
    // Determine what fonts are supported.
    g_DetectedFonts = (new Detector()).identifyCommonFonts();

    testCORS();

    // Update the canvas to configured dimensions.
    var canvas = $("_canvas");
    canvas.width = g_Origin.imageWidth;
    canvas.height = g_Origin.imageHeight;
    addEventHandler( canvas, "dragover", cancel );
    addEventHandler( canvas, "dragenter", cancel );
    addEventHandler( canvas, "drop", imageHandleDrop );

    createFontSelectionElements( "titleProperties", g_TitleFontDesc );
    createFontSelectionElements( "recipientProperties", g_RecipientFontDesc );
    createFontSelectionElements( "memberProperties", g_MemberFontDesc );
    createFontSelectionElements( "masterProperties", g_MasterFontDesc );

    // Create the Members/Masters forms.
    for( var i = 0; i < g_Origin.maxMembers; ++i ) {
       var element = document.createElement( "div" );
       element.setAttribute( "class", "row" );
       element.setAttribute( "draggable", "true" );
       element.setAttribute( "id", "" + i );
       var str = "<span class='tooltip' id='tr" + i + "' onClick='deleteRow(" + i + ")'>&#9949;" +
                 "<span class='tooltiptext'>Delete this row</span></span> " +
                "Member <input class=textInput type='text' name='member' id='p" + i + "' list=membersList" +
                 " onChange='buildCanvas()'/>" +
                 " works with <select class=dropDown name=masters id='m" + i + "' onChange='buildCanvas()'>\n";

       g_MastersList.sort();
       for( var j = 0; j < g_MastersList.length; ++j ) {
           var name = g_MastersList[j].toUpperCase();
           str += "<option value=\"" + name + "\">" + name + "</option>\n";
       }
       str += "</select>";
       element.innerHTML = str;

       $("members").appendChild( element );
    }

    // Populate the date in the title.
    $("t2").value = getDateString() + "    Duration: 20 min";

    // Update the "Download image" anchor element to download the canvas as a PNG file.
    var dl = $("downloadLink");
    addEventHandler( dl,
                     "click", 
                     function() { 
                         saveMembers();
                         loadMembers();
                         this.href = _canvas.toDataURL("image/png");
                         var name = $("f").value;
                         if( name === "" ) name = "image.png";
                         this.download = name;
                     } );

    // Support for draggable elements.
    var rows = document.querySelectorAll('#members .row');
    [].forEach.call(rows, function(row) {
      addEventHandler( row, 'dragstart', memberHandleDragStart );
      addEventHandler( row, 'dragenter', memberHandleDragEnter );
      addEventHandler( row, 'dragover', memberHandleDragOver );
      addEventHandler( row, 'dragleave', memberHandleDragLeave );
      addEventHandler( row, 'drop', memberHandleDrop );
      addEventHandler( row, 'dragend', memberHandleDragEnd );
    });

    if( g_CORSEnabled ) {
        // If CORS is enabled then prevent image URLs being enterred.
        $("_imageInput").style.display = "none";
    }

    // Set default element values
    initializeElementsFromHash( g_ElementDefaults );

    if( window.location.href.indexOf( "?" ) != -1 ) {
        // Set element values from URL parameters
        setParametersFromUrl( window.location.href );
    } else {
        var profiles = getProfiles();
        var day = (new Date()).getDay();

        // Try to find the last profile created on this weekday
        for( var i = 0; i < profiles.length; ++i ) {
            if( parseInt(profiles[i]["day"]) == day ) {
                // Set values to selected profile.
                initializeElementsFromHash( profiles[i] );
                break;
            }
        }
    }

    createProfilesElement( "profiles" );
    loadMembers();

    //$("tort").value = "10";  // XXX REMOVE

    buildCanvas();
}

//
//////////////////////////////////////////////////////

  </script>
</head>
  <style>
    /* Prevent the text contents of draggable elements from being selectable. */
    [draggable] {
      -moz-user-select: none;
      -khtml-user-select: none;
      -webkit-user-select: none;
      user-select: none;
      /* Required to make elements draggable in old WebKit */
      -khtml-user-drag: element;
      -webkit-user-drag: element;
    }
    .dropDown {
      background-color: #FFE2E1
    }
    .textInput {
      background-color: #E2DDED;
    }
    .row {
      border: 2px solid #666666;
      background-color: #ccc;
      margin-right: 5px;
      -webkit-border-radius: 10px;
      -ms-border-radius: 10px;
      -moz-border-radius: 10px;
      border-radius: 10px;
      -webkit-box-shadow: inset 0 0 3px #000;
      -ms-box-shadow: inset 0 0 3px #000;
      box-shadow: inset 0 0 3px #000;
      text-align: center;
      cursor: move;
    }
    .row header {
      color: #fff;
      text-shadow: #000 0 1px;
      box-shadow: 5px;
      padding: 5px;
      background: -moz-linear-gradient(left center, rgb(0,0,0), rgb(79,79,79), rgb(21,21,21));
      background: -webkit-gradient(linear, left top, right top,
                                   color-stop(0, rgb(0,0,0)),
                                   color-stop(0.50, rgb(79,79,79)),
                                   color-stop(1, rgb(21,21,21)));
      background: -webkit-linear-gradient(left center, rgb(0,0,0), rgb(79,79,79), rgb(21,21,21));
      background: -ms-linear-gradient(left center, rgb(0,0,0), rgb(79,79,79), rgb(21,21,21));
      border-bottom: 1px solid #ddd;
      -webkit-border-top-left-radius: 10px;
      -moz-border-radius-topleft: 10px;
      -ms-border-radius-topleft: 10px;
      border-top-left-radius: 10px;
      -webkit-border-top-right-radius: 10px;
      -ms-border-top-right-radius: 10px;
      -moz-border-radius-topright: 10px;
      border-top-right-radius: 10px;
    }
    .row.over {
      border: 2px dashed #000;
    }
    .inputTable {
      border: 4px solid red;
      border-radius: 20px;
      padding: 10px;
    }
    .imageTable {
      border: 2px solid green;
    }
    .tooltip {
        position: relative;
        display: inline-block;
        border-bottom: 1px dotted black;
    }
    .tooltip .tooltiptext {
        visibility: hidden;
        width: 150px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 6px;
        padding: 5px 0;
        position: absolute;
        z-index: 1;
        top: 150%;
        left: 50%;
        margin-left: -60px;
        
        /* Fade in tooltip - takes 1 second to go from 0% to 100% opac: */
        opacity: 0;
        transition: opacity 1s;
    }
    .tooltip .tooltiptext::after {
        content: "";
        position: absolute;
        bottom: 100%;
        left: 50%;
        margin-left: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: transparent transparent black transparent;
    }
    .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
    }
  </style>
  <body onLoad=pageSetup()>
    <script src="jscolor.min.js"></script>
    <script src="jsurl.js"></script>
    Click <a href=help.html>here</a> for help.
    <a id="downloadLink" href="#image">Download</a> image as filename
    <input class=textInput type='text' name="name" id="f" value="download.png" size="60"/><br>
    Profiles: <span id='profiles'></span> <span class='tooltip'><button type='button' onclick='saveProfile()'>Save profile</button><span class=tooltiptext>Save current settings profile</span></span>
    
    <div id="membersDatalist"></div>

    <table class='inputTable'>
      <tr>
        <td>
        <h2>Group Torus Title</h2>
        Title 1: <span class='tooltip'><input class=textInput type='text' name='t1' id='t1' size='40' value='' onChange='buildCanvas()'><span class='tooltiptext'>Title used in the image header and download filename.</span></input></span><br>
        Title 2: <input class=textInput type='text' name='t2' id='t2' size='40' value='Duration: 20 min' onChange='buildCanvas()'/><br>
        part (optional) <input class=textInput type='text' name='tp' id='tp' size='20' value='' onChange='buildCanvas()'/>
            <span class='tooltip'><input class="jscolor" id='tpc' value="000000" size='4' onchange='buildCanvas()'><span class='tooltiptext'>Colour selector for<br/><b>part (optional)</b></span></span> <br>
        Font <span id='titleProperties'></span>
            <span class='tooltip'><input class="jscolor" id='tc' value="000000" size='4' onchange='buildCanvas()'><span class='tooltiptext'>Colour selector for<br/><b>Title 1</b> and <b>Title 2</b></span></span><br>

        <h2>Members / Masters</h2>
        <i><b>Members are added to the torus in a <select class=dropDown name=order id=or onchange='buildCanvas()'>
            <option value='counter'>counter-clockwise</option>
            <option value='clockwise'>clockwise</option>
        </select> order.   Masters are on the<br> right (counter-clockwise) of members.<br></b></i>
        <div id="members"></div>

        <p id="_error"></p>

        Member font <span id='memberProperties'></span>
            <span class='tooltip'><input class="jscolor" id='pc' value="000000" size='4' onchange='buildCanvas()'><span class='tooltiptext'>Colour selector for <br/>member names.</span></span> <br>
        Master font <span id='masterProperties'></span>
            <span class='tooltip'><input class="jscolor" id='mc' value="000000" size='4' onchange='buildCanvas()'><span class='tooltiptext'>Colour selector for<br/>master names.</span></span> <br>
        Orientation for first member is
        <select class=dropDown name=orientation id=o onChange='buildCanvas()'>
            <option value=270>North (N)</option>
            <option value=292.5>North-Northeast (NNE)</option>
            <option value=315>Northeast (NE)</option>
            <option value=337.5>East-Northeast (ENE)</option>
            <option value=0>East (E)</option>
            <option value=22.5>East-Southeast (ESE)</option>
            <option value=45>Southeast (SE)</option>
            <option value=67.5>South-Southeast (SSE)</option>
            <option value=90>South (S)</option>
            <option value=112.5>South-Southwest (SSW)</option>
            <option value=135>Southwest (SW)</option>
            <option value=157.5>West-Southwest (WSW)</option>
            <option value=180>West (W)</option>
            <option value=202.5>West-Northwest (WNW)</option>
            <option value=225>Northwest (NW)</option>
            <option value=247.5>North-Northwest (NNW)</option>
        </select>
        <div/>
        <br/>
        <h2>Torus Circle</h2>
        <table border=0>
          <tr>
            <td>Background colour:</td>
            <td><input class="jscolor" id='bgc' value="FFFFFF" size='6' onchange='buildCanvas()'></td>
          </tr><tr>
            <td>Torus circle</td>
            <td>
              <table border=1>
                <tr>
                  <td>circle treatment:</td>
                  <td>
                    <span class=tooltip>
                      <select class=dropDown name=torusWidth id='tort' onChange='buildCanvas()'>
                        <option value=0>None</option>
                        <option value=1>HEART</option>
                        <option value=2>RANDOM</option>
                        <option value=3>FLOWER_OF_LIFE</option>
                        <option value=4>METATRONS_CUBE</option>
                        <option value=5>DAISY</option>
                        <option value=6>PETALS</option>
                        <option value=7>MESH (per members)</option>
                        <option value=8>GEOMETRIC_1 (per members)</option>
                        <option value=9>IMAGE</option>
                      </select>
                      <span class=tooltiptext>Pattern to display within torus circle</span>
                    </span>
                    <span class=tooltip>
                      <input class="jscolor" id='tortc' value="000000" size='6' onchange='buildCanvas()'> <br>
                      <span class=tooltiptext>Colour selector for pattern in torus</span>
                    </span>
                   </td>
                </tr><tr>
                  <td>circle size:</td>
                  <td>
                    <select class=dropDown name=torusSize id='tors' onChange='buildCanvas()'>
                      <option value=100>100px</option>
                      <option value=110>110px</option>
                      <option value=120>120px</option>
                      <option value=130>130px</option>
                      <option value=140>140px</option>
                      <option value=150>150px</option>
                    </select>
                  </td>
                </tr><tr>
                  <td>circle width:</td>
                  <td>
                    <select class=dropDown name=torusWidth id='torw' onChange='buildCanvas()'>
                      <option value=2>2px</option>
                      <option value=3>3px</option>
                      <option value=4>4px</option>
                      <option value=5>5px</option>
                      <option value=6>6px</option>
                      <option value=7>7px</option>
                    </select>
                  </td>
                </tr><tr>
                  <td>circle colour:</td>
                  <td>
                    <span class=tooltip>
                      <input class="jscolor" id='torc' value="000000" size='6' onchange='buildCanvas()'>
                      <span class=tooltiptext>Colour selector for torus circle</span>
                    </span>
                </tr>
              </table>
                  </td>
            </td>
          </tr><tr>
            <td>Torus peg</td>
            <td>
              <table border=1>
                <tr>
                  <td>peg treatment:</td>
                  <td>
                    <select class=dropDown name=pegTreatment id='pegt' onChange='buildCanvas()'>
                      <option value=0>None</option>
                      <option value=1>Circle</option>
                      <option value=2>Square</option>
                      <option value=3>Diamond</option>
                      <option value=4>Heart</option>
                    </select>
                  </td>
                </tr><tr>
                  <td>peg width:</td>
                  <td>
                    <select class=dropDown name=pegWidth id='pegw' onChange='buildCanvas()'>
                      <option value=5>5px</option>
                      <option value=6>6px</option>
                      <option value=7>7px</option>
                      <option value=8>8px</option>
                      <option value=9>9px</option>
                      <option value=10>10px</option>
                    </select>
                  </td>
                </tr><tr>
                  <td>peg colour:</td>
                  <td>
                    <span class=tooltip>
                      <input class="jscolor" id='torpc' value="000000" size='6' onchange='buildCanvas()'>
                      <span class=tooltiptext>Colour selector for pegs</span>
                    </span>
                  </td>
                </tr><tr>
                  <td>peg border colour:</td>
                  <td>
                    <span class=tooltip>
                      <input class="jscolor" id='torpbc' value="000000" size='6' onchange='buildCanvas()'>
                      <span class=tooltiptext>Colour selector for<br/>peg borders</span>
                    </span>
                  </td>
                </tr>
              </table>
            </td>
          </tr>
        </table>

        <h2>Recipient (optional)</h2>
        Recipient: <span class='tooltip'><input class=textInput type='text' name='rep' id='rep' size='40' value='' onChange='buildCanvas()'/><span class='tooltiptext'>Optional name for center of torus</span></span><br>
        Font <span id='recipientProperties'></span>
            <span class='tooltip'><input class="jscolor" id='rc' value="000000" size='6' onchange='buildCanvas()'><span class='tooltiptext'>Colour selector for <b>Recipient</b></span></span> <br>
        <span id=_imageInput>
            Image: <input class=textInput type='text' name='tori' id='tori' size='80' value='' onChange='newImage()'/><br>
        </span>
      </td>
      <td valign=top>
          <table class=imageTable cellpadding=4>
            <tr><td>
              <canvas id=_canvas width=100 height=50 crossOrigin="Anonymous"></canvas>
            </td></tr>
          </table>
      </td>
    </table>

    <br/>
    Debug enabled: <input type=checkbox id='_debug' onChange='buildCanvas()'><br>
    My URL: <span id='_myURL'></span>
    <canvas id=_testCanvas width=5 height=5></canvas>
  </body>
</html>
