<!DOCTYPE html>
<html lang="en">
<head>
  <title>Image Generator</title>
  <meta charset="utf-8"/>
  <script type="text/javascript">

//////////////////////////////////////////////////////
//
// Author:      Richard Czegledi
// Date:        September 21, 2018
//
// ID Legend:
//  $("_canvas")    - canvas element for drawing image
//  $("_debug")     - checkbox for enabling debug mode
//  $("_myURL")     - URL name with parameters
//  $("_profile")   - profile name
//  $("_imageInput") - elements for accepting image URL

//  $("t1")         - title string 1
//  $("t2")         - title string 2
//  $("tp")         - title part (e.g. "Group A")
//  $("tff")        - title font family
//  $("tfb")        - title font bold selected
//  $("tfi")        - title font italic selected 
//  $("tfs")        - title font shadow selected
//  $("tfp")        - title font size
//  $("tc")         - title colour
//  $("tpc")        - title part colour

//  $("rep")        - recipient name in center of torus
//  $("rff")        - recipient font family
//  $("rfb")        - recipient font bold selected
//  $("rfi")        - recipient font italic selected
//  $("rfs")        - recipient font shadow selected
//  $("rfp")        - recipient font size
//  $("rc")         - recipient colour

//  $("tr#")        - trash member/master # (from 0)

//  $("p#")         - member # (from 0)
//  $("pff")        - member font family
//  $("pfb")        - member font bold selected
//  $("pfi")        - member font italic selected
//  $("pfs")        - member font shadow selected
//  $("pfp")        - member font size
//  $("pc")         - member colour

//  $("m#")         - master # (from 0)
//  $("mff")        - master font family
//  $("mfb")        - master font bold selected
//  $("mfi")        - master font italic selected
//  $("mfs")        - master font shadow selected
//  $("mfp")        - master font size
//  $("mc")         - master colour

//  $("bgc")        - background colour
//  $("o")          - orientation
//  $("or")         - torus addition order
//  $("tors")       - torus size in px
//  $("torw")       - torus width in px
//  $("torc")       - torus colour
//  $("tort")       - torus treatment
//  $("torlt")      - torus line treatment
//  $("tortc")      - torus treament colour
//  $("torpc")      - torus peg colour
//  $("torpbc")     - torus peg border colour
//  $("tori")       - torus image
//  $("pegt")       - peg treatment
//  $("pegw")       - peg width
//  $("_error")     - error string
//  $("f")          - image filename

var g_Debug = false;

var ALIGNMENT = { LEFT:0, CENTER:1, RIGHT:2, AUTO:3 };

var OBJECT_TYPE = { TITLE:0, MEMBER:1, MASTER:2, RECIPIENT:3};

var TORUS_TREATMENT = { NONE:0, HEART:1, RANDOM:2, FLOWER_OF_LIFE:3, METATRONS_CUBE:4,
                        DAISY:5, PETALS:6,
                        MESH:7, GEOMETRIC_1:8, IMAGE:9, GOLDEN_SPIRAL:10,
                        METATRON_2:11};

var PEG_TREATMENT = { NONE:0, CIRCLE:1, SQUARE:2, DIAMOND:3, HEART:4 };

var CIRCLE_TREATMENT = { SOLID:0, WAVE:1, RIPPLE:2 };

var g_DragSrcEl = null;

var g_TorusImage = null;

var g_TorusTreament = TORUS_TREATMENT.NONE;

var g_PegTreatment = PEG_TREATMENT.CIRCLE;

var g_CORSEnabled = true;

var g_AllMembers = [];

var g_Images = {
                "Sacred Geometry 1":    {file:"sacred1.jpg",        type:"clip"},
                "Sacred Geometry 2":    {file:"sacred2.jpg",        type:"clip"},
                "Sacred Geometry 3":    {file:"sacred3.jpg",        type:"clip"},
                "Sacred Geometry 4":    {file:"sacred4.jpg",        type:"clip"},
                "Sacred Geometry 5":    {file:"sacred5.jpg",        type:"clip", scale:0.8},
                "Sacred Geometry 6":    {file:"sacred6.jpg",        type:"clip"},
                "Sacred Geometry 7":    {file:"sacred7.jpg",        type:"clip"},
                "Sacred Geometry 8":    {file:"sacred8.jpg",        type:"clip"},
                "Sacred Geometry 9":    {file:"sacred9.jpg",        type:"clip"},
                "Sacred Geometry 10":   {file:"sacred10.jpg",       type:"clip"},
                "Metatron":             {file:"picture1.jpg",       type:"clip"},
                "Ocean":                {file:"picture2.jpg",       type:"clip"},
                "Stained Glass":        {file:"picture3.jpg",       type:"clip"},
                "Flower":               {file:"picture4.jpg",       type:"clip"},
                "Flower 2":             {file:"picture5.jpg",       type:"clip"},
                "Flower 3":             {file:"picture6.jpg",       type:"clip"},
                "Clouds 1":             {file:"picture7.jpg",       type:"clip"},
                "Clouds 2":             {file:"picture8.jpg",       type:"clip"},
                "Clouds 3":             {file:"picture9.jpg",       type:"clip"}
               };

// NOTE: font description MUST include the font height in 'px'.
var g_RecipientFontDesc = { 
    fontFamilyID:               "rff",
    fontBoldID:                 "rfb",
    fontItalicID:               "rfi",
    fontSizeID:                 "rfp",
    fontShadowID:               "rfs",

    textColorID:                "rc",
    debugColor:                 "green",

    torusColorID:               "torc",         // extra colour attribute for torus
    torusPegColorID:            "torpc",        // extra colour attribute for torus peg
    torusPegBorderColorID:      "torpbc",       // extra colour attribute for torus peg border 
    torusTreatmentColorID:      "tortc",        // extra colour attribute for torus treatment
    imageColor:                 "white"         // extra colour attribute for image
};

var g_TitleFontDesc = { 
    fontFamilyID:               "tff",
    fontBoldID:                 "tfb",
    fontItalicID:               "tfi",
    fontSizeID:                 "tfp",
    fontShadowID:               "tfs",

    textColorID:                "tc",
    titleGroupColorID:          "tpc",        // extra color attribute to title group
    debugColor:                 "green"
};

var g_MemberFontDesc = { 
    fontFamilyID:               "pff",
    fontBoldID:                 "pfb",
    fontItalicID:               "pfi",
    fontSizeID:                 "pfp",
    fontShadowID:               "pfs",

    textColorID:                "pc",
    debugColor:                 "green"
};

var g_MasterFontDesc = { 
    fontFamilyID:               "mff",
    fontBoldID:                 "mfb",
    fontItalicID:               "mfi",
    fontSizeID:                 "mfp",
    fontShadowID:               "mfs",

    textColorID:                "mc",
    debugColor:                 "green"
};

var g_ElementDefaults = {
                        // Font Family      bold?       italic?      shadow?        Font Size   Text Color
    /* Title */         tff:"Arial",        tfb:"true", tfi:"false", tfs:"false",   tfp:"16px", tc:"3605FF",       
    /* Recipient */     rff:"Arial",        rfb:"true", rfi:"false", rfs:"false",   rfp:"14px", rc:"14811E",
    /* Member */        pff:"Arial",        pfb:"true", pfi:"false", pfs:"false",   pfp:"14px", pc:"000000",
    /* Master */        mff:"Arial",        mfb:"true", mfi:"false", mfs:"false",   mfp:"14px", mc:"000000",

    t1:"Group Torus",   // Title 1 string

    o:"270",            // orientation
    or:"counter",       // counter-clockwise additions

    bgc:"FFFFFF",       // background colour
    tors:"100",         // torus size
    torw:"3",           // torus circle width
    tort:"0",           // torus treatment
    torlt:"0",          // torus line treatment
    tortc:"000000",     // torus treatment colour
    tpc:"FF15C8",       // title group color
    pegt:"1",           // peg treatment
    pegw:"6",           // peg width

    torc:"000000",      // torus color
    torpc:"FF0000",     // torus peg color
    torpbc:"000000",    // torus peg border colour
    pc:"000000",        // member color
    mc:"FF0000"         // master color
};

var g_MastersList = [
    "",

    // Ascended Masters
    "Mary Magdalene",               "Jesus",                "St Germain",
    "El Morya",                     "Dom Ignacio",          "Lady Nada",
    "Lao Tze",                      "Paul The Venetian",    "Melchizedek",
    "Maha Chohan",                  "Kuan Yin",             "Hilarion",
    "Kuthumi",                      "Lord Lanto",           "Pallas Athena",
    "Mother Mary",                  "Isis",                 "Serapis Bey",
    "St John, the Baptist",         "Eros",                 "Ma'at",
    "Amen Bey",                     "Ptah",                 "Thomas Merton",
    "Portia",                       "Anubis",               "Quetzacoatl",
    "Freya",                        "Moses",                "Vesta",
    "Chananda",                     "Yogananda",            "Gautama Buddha",
    "Maitreya",                     "Cha Ara",              "Hinenuitepo",
    "St Anthony of Padua",          "Pele",

    // Archangels
    "AA Michael",                   "AA Charity",           "AA Uzziel",
    "AA Christine",                 "AA Jophiel",           "AA Hope",
    "AA Chamuel",                   "AA Faith",             "AA Gabriel",
    "AA Raphael",                   "AA Ariel",             "AA Aurora",
    "AA Uriel",                     "AA Amethyst",          "AA Zadkiel",
    "AA Metatron",

    // Cosmic Masters
    "White Tara",                   "Ganesh",               "Sanat Kumara",
    "Susan'oo",                     "Ra-mun",               "Vishnu",
    "Helios",                       "Shiva",                "Osiris",
    "Ares",                         "Metatron",             "Sitatapatra",
    "Krishna",                      "Amaryllis",            "Hathor",
    "Inanna",                       "Amaterasu",            "Omri Tas",
    "Lakshmi",

    // Elohim
    "Amazonia",                     "Hercules",             "Apollo",
    "Lumina",                       "Heros",                "Amora",
    "Purity",                       "Cyclopea",             "Virginia",
    "Astrea",                       "Cassiopea",            "Peace",
    "Aloha",                        "Arcturus",             "Victoria",
    "Elohim of the 8th ray" ];


// Object to define origin within canvas.
var g_Origin = {
    // Center X,Y coordinates of center circle.
    imageWidth:                 800,
    imageHeight:                800,

    imageCenterX:               400,            // imageWidth/2
    imageCenterY:               400,            // imageHeight/2

    torusRingSize:              100,            // initial size of torus circle 
    torusRingWidth:             3,              // px for the torus circle
    torusRingSpacing:           6,              // px spacing abound torus circle
    torusRingMasterSpacing:     75,             // px spacing from torus circle to master names

    torusRingPegSize:           6,              // px size of pegs on torus circle

    memberSpacing:              5,              // px spacing around member names
    masterSpacing:              15,             // px spacing around master names

    memberStartAngle:           90,             // initial angle for member name

    cropSpacing:                5,              // px spacing from entire image to border

    titleSpacing:               20,             // px spacing from title to any member/master name

    maxMembers:                 16,             // maximum number of members supported
    maxDropDownMembers:         15,             // maximum number of members in drop down list

    maxProfiles:                7,              // maximum number of cookie profiles supported
    maxCookieDays:              365,            // maximum days to keep a cookie

    absXY : function( relX, relY ) {
        return { x: Math.round( this.imageCenterX + relX ),
                 y: Math.round( this.imageCenterY + relY ) };
    },

    polarToAbsXYWithOffset : function( radius, angle, offsetX, offsetY ) {
        return this.absXY( offsetX + radius * Math.cos( angle * Math.PI / 180 ),
                           offsetY + radius * Math.sin( angle * Math.PI / 180 ) );
    },

    polarToAbsXY : function( radius, angle ) {
        return this.polarToAbsXYWithOffset( radius, angle, 0, 0 );
    },

    resetImageCenter : function() {
        this.imageCenterX = this.imageWidth / 2;
        this.imageCenterY = this.imageHeight / 2;
    },

    setImageCenter : function( x, y ) {
        this.imageCenterX = x;
        this.imageCenterY = y;
    } 
};


var g_DetectedFonts = {};
var g_Title = [];
var g_Members = [];
var g_ObjectArray = [];



function resetGlobals() {
    g_Title = [];
    g_Members = [];
    g_ObjectArray = [];
    g_Origin.resetImageCenter();
}

function resetCookies() {
    for( let i = 0; i < g_Origin.maxProfiles; ++i ) {
        eraseCookie( "profile" + i );
    }
}

/**
 * JavaScript code to detect available availability of a
 * particular font in a browser using JavaScript and CSS.
 *
 * Author : Lalit Patel
 * Website: http://www.lalit.org/lab/javascript-css-font-detect/
 * License: Apache Software License 2.0
 *          http://www.apache.org/licenses/LICENSE-2.0
 * Version: 0.15 (21 Sep 2009)
 *          Changed comparision font to default from sans-default-default,
 *          as in FF3.0 font of child element didn't fallback
 *          to parent element if the font is missing.
 * Version: 0.2 (04 Mar 2012)
 *          Comparing font against all the 3 generic font families ie,
 *          'monospace', 'sans-serif' and 'sans'. If it doesn't match all 3
 *          then that font is 100% not available in the system
 * Version: 0.3 (24 Mar 2012)
 *          Replaced sans with serif in the list of baseFonts
 */
/**
 * Usage: d = new Detector();
 *        d.detect('font name');
 */
var Detector = function() {
    // a font will be compared against all the three default fonts.
    // and if it doesn't match all 3 then that font is not available.
    let baseFonts = ['monospace', 'sans-serif', 'serif'];

    //we use m or w because these two characters take up the maximum width.
    // And we use a LLi so that the same matching fonts can get separated
    let testString = "mmmmmmmmmmlli";

    //we test using 72px font size, we may use any size. I guess larger the better.
    let testSize = '72px';

    let h = document.getElementsByTagName("body")[0];

    // create a SPAN in the document to get the width of the text we use to test
    let s = document.createElement("span");
    s.style.fontSize = testSize;
    s.innerHTML = testString;
    let defaultWidth = {};
    let defaultHeight = {};
    for (let index in baseFonts) {
        //get the default width for the three base fonts
        s.style.fontFamily = baseFonts[index];
        h.appendChild(s);
        defaultWidth[baseFonts[index]] = s.offsetWidth; //width for the default font
        defaultHeight[baseFonts[index]] = s.offsetHeight; //height for the defualt font
        h.removeChild(s);
    }

    function detect(font) {
        let detected = false;
        for (let index in baseFonts) {
            s.style.fontFamily = font + ',' + baseFonts[index]; // name of the font along with the base font for fallback.
            h.appendChild(s);
            let matched = (s.offsetWidth != defaultWidth[baseFonts[index]] || s.offsetHeight != defaultHeight[baseFonts[index]]);
            h.removeChild(s);
            detected = detected || matched;
        }
        return detected;
    }

    function identifyCommonFonts() {
        // list of 'common' fonts to search
        let commonFonts = ["cursive", "monospace", "serif", "sans-serif", "fantasy", "default", "Arial",
                           "Arial Black", "Arial Narrow", "Bookman Old Style", "Century",
                           "Century Gothic", "Comic Sans MS", "Courier", "Courier New", "Georgia", "Gentium",
                           "Impact", "King", "Lucida Console", "Lalit", "Modena", "Monotype Corsiva", "Papyrus",
                           "Tahoma", "TeX", "Times", "Times New Roman", "Trebuchet MS", "Verdana", "Verona"];
        let detectedFonts = [];

        for( let i=0; i < commonFonts.length; ++i ) {
            if( detect(commonFonts[i]) ) {
                detectedFonts.push( commonFonts[i] );
            }
        }
        return detectedFonts;
    }

    this.detect = detect;
    this.identifyCommonFonts = identifyCommonFonts;
};

function computeSeed() {
    let seed = 12345;
    for( let i = 0; i < g_Origin.maxMembers; ++i ) {
        let member = $("p" + i).value;
        let master = $("m" + i).value;
        
        if( member !== "" ) {
            for( let j = 0; j < member.length; ++j ) {
                seed = ((seed + member.charCodeAt(j)) * 53) % 0x80000000;
            }
        }
        if( master !== "" ) {
            for( let j = 0; j < master.length; ++j ) {
                seed = ((seed + master.charCodeAt(j)) * 53) % 0x80000000;
            }
        }
    }
    return seed;
}

function myRand(seed) {
    this.m = 0x80000000;    // 2**31
    this.a = 1103515245;
    this.c = 12345;
    this.state = seed ? seed : Math.floor(Math.random() * (this.m-1));
}
myRand.prototype.nextInt = function() {
    this.state = (this.a * this.state + this.c) % this.m;
    return this.state;
}
myRand.prototype.nextRange = function(start, end) {
    this.state = (this.a * this.state + this.c) % this.m;
    return start + Math.floor( this.state / this.m * (end-start) );
}
myRand.prototype.randColour = function(hex, opacity) {
	// validate hex string
	hex = String(hex).replace(/[^0-9a-f]/gi, '');
	if (hex.length < 6) {
		hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
	}
    let bgHex = colorFromID("bgc");
	bgHex = String(bgHex).replace(/[^0-9a-f]/gi, '');
	if (bgHex.length < 6) {
		bgHex = bgHex[0]+bgHex[0]+bgHex[1]+bgHex[1]+bgHex[2]+bgHex[2];
	}

	let rgba = "rgba(", c, i;
	for (i = 0; i < 3; i++) {
		hexVal = parseInt(hex.substr(i*2,2), 16);
		bgHexVal = parseInt(bgHex.substr(i*2,2), 16);

        if( hexVal < bgHexVal ) {
            c = this.nextRange( hexVal, bgHexVal );
        } else {
            c = this.nextRange( bgHexVal, hexVal );
        }

		c = Math.round(Math.min(Math.max(0, c), 255)).toString();
        if( i > 0 ) rgba += ",";
		rgba += c;
	}

    rgba += opacity.toString() + ")";
	return rgba;
}



function $(id) {
    return document.getElementById(id);
}

function massageName( name ) {
    let arr = [];

    // Determine if the name needs to be split.
    if( name.length >= 10 ) {
        let slash = name.indexOf( " / " );
        if( slash > 0 ) {
            let start = 0;
            while( slash > 0 ) {
                slash += 3;
                arr.push( {text:myTrim( name.slice( start, slash ))} );
                start = slash;
                slash = name.indexOf( " / ", slash );
            }
            arr.push( {text:myTrim( name.slice( start, name.length ))} );
            return arr; 
        }

        let mid = Math.floor( name.length / 2 );
        let bestDistance = name.length;
        let bestIndex = -1;

        for( let i = 0; i < name.length; ++i ) {
            let distance = Math.abs(mid-i);
            if( name[i] == ' ' && distance < bestDistance ) {
                bestIndex = i;
                bestDistance = distance;
            }
        }

        if( bestIndex >= 0 ) {
            // Split the name into two.
            arr.push( {text:myTrim( name.substring( 0, bestIndex ) )} );
            arr.push( {text:myTrim( name.substring( bestIndex, name.length ) )} );
            return arr;
        }

    }

    arr.push( {text:myTrim(name)} );
    return arr;
}

function colorFromID( id ) {
    return "#" + $(id).value;
}

function createSeatingArrangement() {
    let memberAngle = g_Origin.memberStartAngle;
    let step = 360 / g_Members.length;
    let masterAngle = memberAngle - step/2;
    let radiusStep = 1;
    let memberRadius = g_Origin.torusRingSize 
                     + g_Origin.torusRingSpacing
                     + g_Origin.memberSpacing + 1;
    let masterRadius = g_Origin.torusRingSize + g_Origin.torusRingMasterSpacing;
    let titleRadius = masterRadius + g_Origin.titleSpacing;
    let maxRadius = g_Origin.imageCenterY;
    let obj;
    let result = "";
    let context = $("_canvas").getContext("2d");

    if( $("or").value === "counter" ) {
        step = -step;
    }

    // Create the center object.
    obj = createTextObject( OBJECT_TYPE.RECIPIENT,
                            massageName( $("rep").value ),
                            $("_canvas"), 
                            context,
                            g_RecipientFontDesc, 
                            ALIGNMENT.CENTER, 
                            g_Origin, 
                            0,      // radius
                            0,      // angle
                            g_Origin.torusRingSpacing );
    obj.setBoundingRadius( g_Origin.torusRingSize );
    g_ObjectArray.push( obj );

    let memberStartIndex = g_ObjectArray.length;

    // Create the member objects
    for( let i = 0; i < g_Members.length; ++i ) {
        obj = createTextObject( OBJECT_TYPE.MEMBER,
                                massageName( g_Members[i].member ),
                                $("_canvas"), 
                                context,
                                g_MemberFontDesc, 
                                ALIGNMENT.AUTO, 
                                g_Origin, 
                                memberRadius,
                                memberAngle,
                                g_Origin.memberSpacing );
        g_ObjectArray.push( obj );
        memberAngle += step;

        // Attempt to place the member.
        for( let r = memberRadius; r < maxRadius; r += radiusStep ) {
            obj.setRadius( r );
            result = testOverlap();
            if( result == null ) {
                break;
            }
        }

        if( result != null ) {
            // Return the member placement error.
            return result;
        }
    }

    // Create the master objects
    for( let i = 0; i < g_Members.length; ++i ) {
        if( g_Members[i].master !== "" ) {
            obj = createTextObject( OBJECT_TYPE.MASTER,
                                    massageName( g_Members[i].master ),
                                    $("_canvas"), 
                                    context,
                                    g_MasterFontDesc, 
                                    ALIGNMENT.AUTO, 
                                    g_Origin, 
                                    masterRadius,
                                    masterAngle,
                                    g_Origin.masterSpacing );
            g_ObjectArray.push( obj );

            let memberMin, memberMax;
            if( $("or").value === "counter" ) {
                memberMax = g_ObjectArray[ memberStartIndex + i ];
                memberMin = g_ObjectArray[ memberStartIndex + ((i+1) % g_Members.length) ];
            } else {
                memberMin = g_ObjectArray[ memberStartIndex + i ];
                memberMax = g_ObjectArray[ memberStartIndex + ((i-1) % g_Members.length) ];
            }

            let angleA = memberMin.computeMaxAngle();
            let angleB = memberMax.computeMinAngle();
            
            if( angleA < angleB ) {
                obj.setAngle( (angleA + angleB) / 2 );
            } else {
                obj.setAngle( (angleA + angleB + 360) / 2 );
            }

            // Attempt to place the master.
            for( let r = masterRadius; r < maxRadius; r += radiusStep ) {
                obj.setRadius( r );
                result = testOverlap();
                if( result == null ) {
                    break;
                }
            }

            if( result != null ) {
                // Return the master placement error.
                return result;
            }
        }
        masterAngle += step;
    }

    // Create the title object.
    let title = [];
    for( let i = 0; i < g_Title.length; ++i ) {
        title.push( {text:myTrim(g_Title[i]),
                     color:colorFromID(g_TitleFontDesc.textColorID)} );
    }
    if( $("tp").value !== "" ) {
        title.push( {text:myTrim($("tp").value), 
                     color:colorFromID(g_TitleFontDesc.titleGroupColorID)} );
    }

    obj = createTextObject( OBJECT_TYPE.TITLE,
                            title,
                            $("_canvas"), 
                            context,
                            g_TitleFontDesc, 
                            ALIGNMENT.CENTER, 
                            g_Origin, 
                            titleRadius,
                            270,                    // angle
                            g_Origin.titleSpacing  );
    g_ObjectArray.push( obj );

    // Attempt to place the title.
    for( let r = titleRadius; r < maxRadius; r += radiusStep ) {
        obj.setRadius( r );
        result = testOverlap();
        if( result == null ) {
            break;
        } 
    }

    return result;
}

function drawHeart( context, xCenter, yCenter, size, borderColour, innerColour ) {
    let x = xCenter-(size/2);
    let y = yCenter-(size/2);
    let w = size, h = size;
    let d = Math.min(w,h);
    context.strokeStyle = borderColour;
    context.strokeWeight = 3;
    context.shadowOffsetX = 4.0;
    context.shadowOffsetY = 4.0;
    context.lineWidth = size < 20 ? 1 : 5;
    context.beginPath();
    context.moveTo( x, y+d/4 );
    context.quadraticCurveTo( x,y, x+d/4, y);
    context.quadraticCurveTo( x+d/2, y, x+d/2, y+d/4 );
    context.quadraticCurveTo( x+d/2, y, x+d*3/4, y );
    context.quadraticCurveTo( x+d, y, x+d, y+d/4 );
    context.quadraticCurveTo( x+d, y+d/2, x+d*3/4, y+d*3/4 );
    context.lineTo( x+d/2, y+d );
    context.lineTo( x+d/4, y+d*3/4 );
    context.quadraticCurveTo( x, y+d/2, x, y+d/4 );
    if( innerColour != undefined ) {
        context.fillStyle = innerColour;
        context.fill();
    }
    context.closePath();
    context.stroke();
}

function drawPeg( context, x, y ) {
    let colour = colorFromID(g_RecipientFontDesc.torusPegColorID);
    let borderColour = colorFromID(g_RecipientFontDesc.torusPegBorderColorID);
    let pegSize = g_Origin.torusRingPegSize;

    if( g_PegTreatment == PEG_TREATMENT.CIRCLE ) {
        context.strokeStyle = borderColour;
        context.lineWidth = 1;
        context.beginPath();
        context.arc( x, y, pegSize, 0, 2*Math.PI );
        context.fillStyle = colour;
        context.fill();
        context.closePath();
        context.stroke();
    } else if( g_PegTreatment == PEG_TREATMENT.SQUARE ) {
        context.strokeStyle = borderColour;
        context.lineWidth = 1;
        context.beginPath();
        context.moveTo( x-pegSize, y-pegSize );
        context.lineTo( x+pegSize, y-pegSize );
        context.lineTo( x+pegSize, y+pegSize );
        context.lineTo( x-pegSize, y+pegSize );
        context.fillStyle = colour;
        context.fill();
        context.closePath();
        context.stroke();
    } else if( g_PegTreatment == PEG_TREATMENT.DIAMOND ) {
        context.strokeStyle = borderColour;
        context.lineWidth = 1;
        context.beginPath();
        context.moveTo( x, y-pegSize );
        context.lineTo( x+pegSize, y );
        context.lineTo( x, y+pegSize );
        context.lineTo( x-pegSize, y );
        context.fillStyle = colour;
        context.fill();
        context.closePath();
        context.stroke();
    } else if( g_PegTreatment == PEG_TREATMENT.HEART ) {
        drawHeart( context, x, y, pegSize*2, borderColour, colour );
    }
}

function iterateSacred( obj, radius, x, y, centerArray ) {
    let d = distance( x, y, 0, 0 );
    let visible = d <= obj.boundingRadius;
    if( d <= obj.boundingRadius + radius ) {
        for( let i = 0; i < centerArray.length; ++i ) {
            if( Math.abs( centerArray[i].centerX - x ) < 2
             && Math.abs( centerArray[i].centerY - y ) < 2 ) {
                // The point is already added
                return visible;
            }
        }

        let myIndex = centerArray.length;
        centerArray.push( {centerX:x, centerY:y} );

        let points = [];
        for( let angle = 0; angle < 360; angle+=60 ) {
            let newX = x + radius * Math.cos( angle * Math.PI / 180 );
            let newY = y + radius * Math.sin( angle * Math.PI / 180 );
            points[angle/60] = iterateSacred( obj, radius, newX, newY, centerArray );
        }

        centerArray[myIndex].visiblePoints = points;
        return visible;
    }
    return false;
}

function plotRuleStep( context, script ) {
    let rule = script.rule;
    context.beginPath();

    switch( rule.style ) {
        case "bezier":
            var control1 = ('control1' in rule) ? rule.control1
                                                : {x:5*(rule.start.x + rule.end.x)/8, y:rule.start.y};
            var control2 = ('control2' in rule) ? rule.control2
                                                : {x:4*(rule.start.x + rule.end.x)/8, y:rule.end.y};
            context.moveTo( rule.start.x, rule.start.y );
            context.bezierCurveTo( control1.x,       control1.y,
                                   control2.x,       control2.y,
                                   rule.end.x,       rule.end.y );
            context.bezierCurveTo( control2.x,       -control2.y,
                                   control1.x,       -control1.y, 
                                   rule.start.x,     -rule.start.y );
            break;

        case "arc":
            context.arc( rule.center.x,  rule.center.y, 
                         rule.radius,
                         rule.startAngle * Math.PI / 180,
                         rule.endAngle * Math.PI / 180,
                         ('counterclockwise' in rule) ? rule.counterclockwise : false );
            break;
           
        case "ellipse":
            context.ellipse( rule.center.x, rule.center.y,
                             rule.radiusX,  rule.radiusY,
                             rule.rotation,
                             rule.startAngle * Math.PI / 180,
                             rule.endAngle * Math.PI / 180,
                             ('counterclockwise' in rule) ? rule.counterclockwise : false ); 
            break;

        case "lines":
            context.moveTo( rule.start.x,   rule.start.y );
            for( let p in rule.points ) {
                context.lineTo( rule.points[p].x, rule.points[p].y );
            }
            break;

        case "spiral":
            {
                // rule.start           - starting point of spiral
                // rule.startAngle      - angle from starting point
                // rule.direction       - 'true' if backwards (optional)
                // rule.gap             - gap between spirals
                // rule.turns           - number of circle turns
                let center, eAngle, increment, newX, newY, progress, sAngle, tempTheta, theta;
                let angle = rule.startAngle * Math.PI/180;
                let direction = ('direction' in rule) ? rule.direction : false;
                sAngle = Math.PI + angle * Math.PI/18;
                eAngle = sAngle + Math.PI * 2 * rule.turns;
                center = {
                    x: rule.start.x + Math.cos(angle) * rule.gap,
                    y: rule.start.y + Math.sin(angle) * rule.gap
                };
                increment = 2 * Math.PI / 60;  //steps per rotation
                theta = sAngle;

                context.moveTo(center.x, center.y);
                while (theta <= eAngle + increment) {
                    progress = (theta - sAngle) / (eAngle - sAngle);
                    tempTheta = direction ? theta : -1 * (theta - 2 * angle);
                    newX = rule.gap * Math.cos(tempTheta) * progress;
                    newY = rule.gap * Math.sin(tempTheta) * progress;
                    theta += increment;
                    context.lineTo(center.x + newX, center.y + newY);
                }
            }
            break;
    } 

    if( 'strokeStyle' in script || 'lineWidth' in script ) {
        context.stroke();
    }

    if( 'fillStyle' in script ) {
        if( 'fillToCenter' in script ) {
            context.lineTo( 0, 0 );
        }

        context.fillStyle = script.fillStyle;
        context.fill();
    }
}

function iterateRandom( context, arcAngle, script ) {
    if( script.constructor === Array ) {
        for( let i in script ) {
            context.save();
                iterateRandom( context, arcAngle, script[i] );
            context.restore();
        }
    } else if( script.constructor === Object ) {
        let angleDiff = 0;

        if( 'strokeStyle' in script )   context.strokeStyle = script.strokeStyle;
        if( 'lineWidth' in script )     context.lineWidth = script.lineWidth;
        if( 'arcAngle' in script )      arcAngle = script.arcAngle;

        if( 'pre' in script ) {
            iterateRandom( context, arcAngle, script.pre );
        }

        if( 'angleDiff' in script )     angleDiff = script.angleDiff;

        if( 'rule' in script ) {
            for( let angle = 0; angle < 360; angle += arcAngle ) {
                context.save();
                    context.rotate( (angle + angleDiff) * Math.PI / 180 );

                    plotRuleStep( context, script );

                    if( 'contains' in script.rule ) {
                        context.clip();
                        iterateRandom( context, 360, script.rule.contains );
                    }
                context.restore();
            }
        }

        if( 'post' in script ) {
            iterateRandom( context, arcAngle, script.post );
        }
    }
}


function goldenSpiral( obj, p, array, rnd, branch ) {
    var ctx = p.context;
    var startX = 0;
    var startY = 0;
    var length = p.length;
    var flip = p.flip;
    var angle = p.angle;
    var lineWidth = p.lineWidth;
    var side = length;
    var startColour = p.startColour;
    var fai = ((1 + Math.sqrt(5)) / 2);
    var x1 = 0;
    var y1 = 0;
    var x2 = 0;
    var y2 = 0;
    var rotateAngle = angle * Math.PI/180;
    var MIN_LENGTH = 5;
    var DEGREE_FACTOR = Math.PI / 180;
 
    ctx.translate( p.startX, p.startY );
    ctx.rotate( rotateAngle );
    for (var i = 0; i < 8 ; i++) {       
        if( !flip ) {
            setGoldenDraw( [0, -90, -180, 90][i & 3], i==0, i);
        } else {
            setGoldenDraw( [0, 90, -180, -90][i & 3], i==0, i);
        }
    }
 
    function setGoldenDraw(deg,flag,i) {
        if (flag) {
            setXY();
        } else {
            startX = startX + x1 + x2;
            startY = startY + y1 + y2;
            side = Math.sqrt(x1 * x1 + y1 * y1);
            setXY();
        }
 
        function setXY() {
            x1 = Math.cos(deg * DEGREE_FACTOR) * side / fai;
            y1 = Math.sin(deg * DEGREE_FACTOR) * side / fai;
            x2 = Math.cos(deg * DEGREE_FACTOR) * side / (fai*fai);
            y2 = Math.sin(deg * DEGREE_FACTOR) * side / (fai*fai);
        }
 
        var dx = x1 + x2;
        var dy = y1 + y2;

        if( i == 1 ) {
            startY -= dy;
        } else if (i > 1) {
            var dis = fai * Math.sqrt(dx * dx + dy * dy);
            ctx.lineWidth=lineWidth;
            ctx.strokeStyle="#000000";
            ctx.beginPath();
            var x = startX + dx + Math.cos(deg * DEGREE_FACTOR)*dis;
            var y = startY + dy + Math.sin(deg * DEGREE_FACTOR)*dis;
            ctx.moveTo(x, y);
            var step = 90 / (2*Math.PI*dis / 4);
            var adjust = flip ? step : -step;
            for( var k = 0; k < 90; k+=step ) {
                deg += adjust;
                var x = startX + dx + Math.cos(deg * DEGREE_FACTOR)*dis;
                var y = startY + dy + Math.sin(deg * DEGREE_FACTOR)*dis;

                if( (k % 30) < step ) {
                    var absX = p.startX + x*Math.cos(-rotateAngle) + y*Math.sin(-rotateAngle);
                    var absY = p.startY - x*Math.sin(-rotateAngle) + y*Math.cos(-rotateAngle);
                    ctx.strokeStyle = pointColour( obj, {x:absX, y:absY}, startColour );
                }
                ctx.lineTo( x, y );

                if( array && lineWidth > 1 ) {
                    if( branch.outerCondition(k,step,i) ) {
                        let len = branch.outerLength(rnd, length);
                        if( len >= MIN_LENGTH ) {
                            array.push( {context:     ctx,
                                         startX:      p.startX + x*Math.cos(-rotateAngle) + y*Math.sin(-rotateAngle),
                                         startY:      p.startY - x*Math.sin(-rotateAngle) + y*Math.cos(-rotateAngle),
                                         length:      len,
                                         flip:        !flip,
                                         angle:       p.angle + deg,
                                         lineWidth:   lineWidth-1,
                                         startColour: startColour,
                                         id:          "outer-k:"+k.toString()+"-i:"+i.toString()} );
                        }
                    }

                    if( branch.innerCondition(k,step,i) ) {
                        let len = branch.innerLength(rnd, length);
                        if( len >=MIN_LENGTH ) {
                            array.push( {context:     ctx,
                                         startX:      p.startX + x*Math.cos(-rotateAngle) + y*Math.sin(-rotateAngle),
                                         startY:      p.startY - x*Math.sin(-rotateAngle) + y*Math.cos(-rotateAngle),
                                         length:      len,
                                         flip:        flip,
                                         angle:       (p.angle + deg + 180) % 360,
                                         lineWidth:   lineWidth-1,
                                         startColour: startColour,
                                         id:          "inner-k:"+k.toString()+"-i:"+i.toString()} );
                        }
                    }
                }
            }
            ctx.stroke();
        }
    }
}


function iterateSpiralRotate( context, obj, startColour ) {
    var branchParms = [ 
                            {
                                outerCondition:     function(k,step,i)      { return i<4 && (k%30) < step; },
                                outerLength:        function(rnd, length)   { return rnd.nextRange(length/4, length/2); },
                                innerCondition:     function(k,step,i)      { return i<4 && (k%45) < step; },
                                innerLength:        function(rnd,length)    { return rnd.nextRange(length/4, length/3); }
                            },
                            {
                                outerCondition:     function(k,step,i)      { return i<4 && (k%60) < step; },
                                outerLength:        function(rnd, length)   { return rnd.nextRange(length/4, length/2); },
                                innerCondition:     function(k,step,i)      { return i<4 && (k%30) < step; },
                                innerLength:        function(rnd,length)    { return rnd.nextRange(length/4, length/3); }
                            }
                      ];
    let rnd = new myRand( computeSeed() );
    let skipAngle = [60, 45, 90][rnd.nextRange(0, 3)];
    var seedParms = {context:     context,
                     startX:      obj.centerX(), 
                     startY:      obj.centerY(),
                     length:      rnd.nextRange( obj.boundingRadius/2, obj.boundingRadius ) ,
                     flip:        rnd.nextRange( 0, 2 ) == 0,
                     angle:       angle,
                     lineWidth:   rnd.nextRange( 0, 6 )==0 ? 3 : 2,  
                     startColour: startColour};
    var branchSelect = rnd.nextRange( 0, branchParms.length );

    for( var angle = 0; angle < 360; angle += skipAngle ) {
        seedParms.angle = angle;
        var array = [ seedParms ];

        for( var i = 0; i < array.length; ++i ) {
            context.save();
                goldenSpiral( obj, array[i], array, rnd, branchParms[branchSelect] );
            context.restore();
        }
    }
}

function polarToXY( radius, angle, offset ) {
    return { x:radius * Math.cos( angle * Math.PI / 180 ) + (offset == null ? 0 : offset.x),
             y:radius * Math.sin( angle * Math.PI / 180 ) + (offset == null ? 0 : offset.y),
             radius:radius,
             angle:angle };
}

// Shallow object clone function.
function cloneAndReflect( obj ) {
    let newObj = (obj instanceof Array) ? [] : {};
    for (let i in obj) {
        if (obj[i] && typeof obj[i] == "object") {
            newObj[i] = cloneAndReflect( obj[i] );
        }
        else
        {
            newObj[i] = obj[i];
        }
    }
    if( typeof newObj == "object" && "angle" in newObj ) {
        newObj.angle = -newObj.angle;
        newObj.y = -newObj.y;
    }
    return newObj;
}; 


function createScript( obj, arcAngle ) {
    let script = [];
    let seed = computeSeed();
    let rnd = new myRand( seed );
    let radius = obj.boundingRadius;
    let angle = 0;
    let last;

    function randColour( opacity ) {
        if( opacity == null ) {
            opacity = rnd.nextRange( 1, 4 ) / 10;
        }
        return rnd.randColour( colorFromID(g_RecipientFontDesc.torusTreatmentColorID), opacity );
    }

    var iter = 0;
    while( radius > 0 ) {
        let next = [];
        switch( rnd.nextRange(0, 3) ) {
            case 0: 
                // circle with possible reflection
                angle = rnd.nextRange( 0, 8 ) * 5;
                thisRadius = rnd.nextRange( 1, 5 ) * 5;
                next.push( {    strokeStyle:  randColour(),
                                lineWidth:    rnd.nextRange(1,3),
                                rule: {
                                    style:      "arc",
                                    center:     polarToXY( radius-thisRadius, angle ),
                                    radius:     thisRadius,
                                    startAngle: 0,
                                    endAngle:   360
                                } } );
                last = next[next.length-1];
                if( rnd.nextRange( 0, 5 ) == 0 ) {
                    last.fillStyle = randColour();
                }
                radius -= 2*last.rule.radius;
                let count = rnd.nextRange( 0, 8 );
                if( count > 0 ) {
                    last.rule.contains = [];
                    switch( rnd.nextRange( 0, 2 ) ) {
                        case 0:
                            // Radial lines from center of circle
                            for( let i = 0; i < count; ++i ) {
                                last.rule.contains.push( {  strokeStyle:    randColour(),
                                                            lineWidth:      rnd.nextRange(1,3),
                                                            rule: {
                                                                style:      "lines",
                                                                start:      last.rule.center,
                                                                points:     [ polarToXY( last.rule.radius, i*360/count, last.rule.center ) ]
                                                            } } );
                            }
                            break;

                        case 1:
                            let angle = 0;
                            last.rule.contains.push( {  strokeStyle:    randColour(),
                                                        lineWidth:      rnd.nextRange(1,2),
                                                        rule: {
                                                            style:      "bezier",
                                                            start:      polarToXY( last.rule.radius, angle+180+45, last.rule.center ),
                                                            end:        polarToXY( last.rule.radius, angle, last.rule.center )
                                                        } } );
                            if( rnd.nextRange( 0, 2 ) == 0 ) {
                                last.rule.contains.push( {  strokeStyle:    randColour(),
                                                            lineWidth:      rnd.nextRange(1,2),
                                                            rule: {
                                                                style:      "bezier",
                                                                start:      polarToXY( last.rule.radius, angle+180+45, last.rule.center ),
                                                                end:        last.rule.center
                                                            } } );
                            }
                            break;
                    }
                }
                if( angle > 0 ) {
                    next.push( cloneAndReflect( next ) );
                }
                break;

            case 1:
                angle = 0;
                let startRadius = radius - rnd.nextRange(2,5)*10;
                if( startRadius > 0 ) {
                    let aa = arcAngle / (2^rnd.nextRange(0,2));
                    let ad = 0;
                    while( radius > startRadius ) {
                        next.push( {  strokeStyle:  randColour(),
                                      lineWidth:    rnd.nextRange(1,2),
                                      arcAngle:     aa,
                                      rule: {
                                          style:    "bezier",
                                          start:    polarToXY( startRadius, aa ),
                                          end:      polarToXY( radius, angle )
                                      } } );
                        if( rnd.nextRange(0,2) == 0 ) {
                            next[next.length-1].fillStyle = randColour();
                        }
                        radius -= rnd.nextRange( 2, 4 ) * 10;
                    }
                }
                radius = startRadius;
                break;

            case 2:
                angle = rnd.nextRange( 1, 5 ) * 5;
                next.push( {  strokeStyle:    randColour(),
                              lineWidth:      rnd.nextRange(1,3),
                              arcAngle:       arcAngle / (2^rnd.nextRange(0,2)),
                              rule: {
                                style:      "lines",
                                start:      polarToXY( radius - rnd.nextRange( 0, 4 ) * 10, -arcAngle ),
                                points:     [ polarToXY( radius - rnd.nextRange( 0, 3 ) * 10, 0 ) ]
                             } } );
                last = next[next.length - 1];
                if( rnd.nextRange(0,3) == 0 ) {
                    last.fillStyle = last.strokeStyle;
                    if( rnd.nextRange( 0, 2 ) == 0 ) {
                        last.fillToCenter = true;
                    }
                }
                radius = Math.min( last.rule.start.radius, last.rule.points[0].radius );
                next.push( cloneAndReflect( next ) );
                break;
        }
        script.push( next );
        //if( ++iter > 2 ) break;
    }
    return script;
}

function metatron2( context, obj, startColour ) {
    var smallRadius = obj.boundingRadius / 9;
    var largeRadius = 4*smallRadius;
    var arr = [];
    var MAX_OFFSET = 1; // 3 pixels
    var CENTER = {x:0, y:0};

    function computeAngle( p1, p2 ) {
        var theta = Math.atan2( p1.y - p2.y, p1.x - p2.x );
        return (theta >= 0) ? theta / Math.PI * 180
                            : (theta + 2*Math.PI) / Math.PI * 180;
    }

    function addPoint( p ) {
        var distanceFromCenter = distancePoints( p, CENTER );

        if( distanceFromCenter > obj.boundingRadius-smallRadius+0.10 ) {
            return false;
        }

        var angleFromCenter = computeAngle( p, CENTER );

        if( distanceFromCenter > 7*smallRadius && ((angleFromCenter+0.05)%30) > 1 ) {
            return false;
        }

        for( var i in arr ) {
            if( distancePoints( arr[i], p ) < MAX_OFFSET ) {
                return true;
            }
        }
        p.id = arr.length;
        p.lines = [];
        arr.push( p );
        p.distanceFromCenter = distanceFromCenter;
        p.angleFromCenter = angleFromCenter;

        context.strokeStyle = pointColour( obj, {x:obj.centerX()+p.x, y:obj.centerY()+p.y}, startColour );
        context.lineWidth = 1;
        context.beginPath();
        context.arc( p.x, p.y, smallRadius, 0, 2*Math.PI );
        context.stroke();

        if( p == CENTER || Math.abs(distanceFromCenter - largeRadius) < MAX_OFFSET ) {
            p.largeCircle = true;
            context.strokeStyle = pointColour( obj, {x:obj.centerX()+p.x, y:obj.centerY()+p.y}, startColour );
            context.lineWidth = 2;
            context.beginPath();
            context.arc( p.x, p.y, largeRadius, 0, 2*Math.PI );
            context.stroke();
        } else {
            p.largeCircle = false;
        }

        var startAngle = 90;
        for( let angle = startAngle; angle < 360+startAngle; angle+=60 ) {
            let newX = p.x + 2*smallRadius * Math.cos( angle * Math.PI / 180 );
            let newY = p.y + 2*smallRadius * Math.sin( angle * Math.PI / 180 );
            addPoint( {x:newX, y:newY} );
        }
        return true;
    }

    addPoint( CENTER );

    arr.sort( function(a,b){ 
                return Math.abs(b.distanceFromCenter-a.distanceFromCenter) < 0.5
                         ? b.angleFromCenter-a.angleFromCenter 
                         : b.distanceFromCenter-a.distanceFromCenter; } );

    for( var i in arr ) {
        var p1 = arr[i];

/*
        context.strokeStyle = "blue";
        context.beginPath();
        context.arc( p1.x, p1.y, smallRadius/2, 0, 2*Math.PI );
        context.fill();
        context.stroke();
*/

        var targets = [];
        for( var t in arr ) {
            var p2 = arr[t]; 
            if( p1 != p2 ) {
                var angle = normalizeAngle( computeAngle( p2, p1 ) - p1.angleFromCenter );
                if( Math.abs( angle ) < 1 ) {
                    continue;
                }

                var node = {angle:      angle,
                            distance:   distancePoints( p1, p2 ),
                            center:     arr[t]};
                var found = false;

                for( var j in targets ) {
                    var tj = targets[j];
                    if( Math.abs(tj.angle - node.angle) < 1 ) {
                        found = true;
                        if( node.distance > tj.distance ) {
                            targets[j] = node;
                            break;
                        }
                    }
                }
                if( !found ) {
                    targets.push( node );
                }
            }
        }

        targets.sort( function(a,b) { return b.angle - a.angle; } );

        var rays = [0, 
               //     Math.floor( targets.length * 4/27 ),
               //     Math.floor( targets.length * 7/27 ),
                    Math.floor( targets.length * 13/27 ),
               //     Math.floor( targets.length * 19/27 ),
               //     Math.floor( targets.length * 22/27 ),
                    targets.length-1];
    
        context.strokeStyle = pointColour( obj, {x:obj.centerX()+p1.x, y:obj.centerY()+p1.y}, startColour );
        for( var r=0; r < rays.length; ++r ) {
            var t = targets[rays[r]];

            if( p1.lines[t.center.id] ) {
                continue;
            }

            context.beginPath();
            context.moveTo( p1.x, p1.y );
            context.strokeStyle = pointColour( obj, {x:obj.centerX()+t.center.x, y:obj.centerY()+t.center.y}, startColour );
            context.lineTo( t.center.x, t.center.y );
            context.stroke();

            t.center.lines[p1.id] = true;
        }
    }
}

function drawSeatingArrangement() {
    let     minX = maxX = g_Origin.imageCenterX;
    let     minY = maxY = g_Origin.imageCenterY;

    // Restore the canvas to configured dimensions.
    $("_canvas").width = g_Origin.imageWidth;
    $("_canvas").height = g_Origin.imageHeight;
    
    // Compute the image dimensions for cropping.
    if( g_ObjectArray.length > 0 ) {
        let obj = g_ObjectArray[0];
        let maxRadius = obj.origin.torusRingSize + obj.spacing;

        minX = Math.min( minX, obj.centerX() - maxRadius );
        maxX = Math.max( maxX, obj.centerX() + maxRadius );

        minY = Math.min( minY, obj.centerY() - maxRadius );
        maxY = Math.max( maxY, obj.centerY() + maxRadius );

        for( let i = 0; i < g_ObjectArray.length; ++i ) {
            let obj = g_ObjectArray[i];

            minX = Math.min( minX, obj.left() );
            maxX = Math.max( maxX, obj.right() );

            minY = Math.min( minY, obj.top() );
            maxY = Math.max( maxY, obj.bottom() );
        }
    }

    minX = Math.max( minX - g_Origin.cropSpacing, 0 );
    minY = Math.max( minY - g_Origin.cropSpacing, 0 );

    maxX = Math.min( maxX + g_Origin.cropSpacing, g_Origin.imageWidth );
    maxY = Math.min( maxY + g_Origin.cropSpacing, g_Origin.imageHeight );

    // Resize and fill the canvas
    let newWidth = maxX-minX;
    let newHeight = maxY-minY;
    $("_canvas").width = newWidth;
    $("_canvas").height = newHeight;
    
    // Alter the image 'center' before the redraw.
    g_Origin.setImageCenter( g_ObjectArray[0].centerX() - minX,
                             g_ObjectArray[0].centerY() - minY );

    // Draw all the objects.
    for( let i = 0; i < g_ObjectArray.length; ++i ) {
        let obj     = g_ObjectArray[i];

        context = obj.context;
        if( i == 0 ) {
            pegs = [];

            context.fillStyle = g_RecipientFontDesc.imageColor;
            context.fillRect( 0, 0, newWidth, newHeight );

            // Compute all the peg locations
            for( let j = 0; j < g_ObjectArray.length; ++j ) {
                let pegObj = g_ObjectArray[j];

                if( pegObj.objectType == OBJECT_TYPE.MEMBER ) {
                    let peg = pegObj.origin.polarToAbsXY( obj.boundingRadius, pegObj.angle );
                    pegs.push( peg );
                }
            }

            switch( g_TorusTreament ) {
                case TORUS_TREATMENT.MESH:
                    for( j =0; j < pegs.length; ++j ) {
                        for( let k = j+1; k < pegs.length; ++k ) {
                            context.strokeStyle = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);
                            context.lineWidth = 1;
                            context.beginPath();
                            context.moveTo( pegs[j].x, pegs[j].y );
                            context.lineTo( pegs[k].x, pegs[k].y );
                            context.closePath();
                            context.stroke();
                        }
                    }
                    break;
	
                case TORUS_TREATMENT.IMAGE:
                    if( g_TorusImage != undefined && g_TorusImage.complete ) {
                        let width = g_TorusImage.width;
                        let height = g_TorusImage.height;
                        let scale = 2 * obj.boundingRadius / Math.sqrt( width*width + height*height );
                        let newWidth = Math.floor( scale * width );
                        let newHeight = Math.floor( scale * height );
                        
                        context.drawImage( g_TorusImage,
                                           obj.centerX() - newWidth/2,
                                           obj.centerY() - newHeight/2,
                                           newWidth,
                                           newHeight );
                    }
                    break;

                case TORUS_TREATMENT.HEART:
                    drawHeart( context, obj.centerX(), obj.centerY(), obj.boundingRadius, 
                                colorFromID(g_RecipientFontDesc.torusTreatmentColorID) );
                    break;

                case TORUS_TREATMENT.RANDOM:
                    {
                        let startColour = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);
                        let seed = computeSeed();
                        let rnd = new myRand( seed );

                        function polarToXY( radius, angle ) {
                            if( radius == null ) {
                                radius = rnd.nextRange( 0, obj.boundingRadius );
                            }
                            if( angle == null ) {
                                angle = rnd.nextRange( 0, 360 );
                            } 
                            return { x:radius * Math.cos( angle * Math.PI / 180 ),
                                     y:radius * Math.sin( angle * Math.PI / 180 ),
                                     radius:radius,
                                     angle:angle };
                        }

                        context.save();
                        context.beginPath();
                        context.arc( obj.centerX(), obj.centerY(), 
                                     obj.boundingRadius + 1, 0, 2*Math.PI );
                        context.clip();

                        context.translate( obj.centerX(), obj.centerY() );
                        context.lineJoin = "round";

                        let arcAngle = 360 / 8;
                        let radius = obj.boundingRadius - 10;
                        let depth = 40;

                        iterateRandom( context, arcAngle, createScript( obj, arcAngle ) );
                        context.restore();
                    }
                    break;

                case TORUS_TREATMENT.GEOMETRIC_1:
                    {
                        for( let j = 0; j < g_ObjectArray.length; ++j ) {
                            let pegObj = g_ObjectArray[j];

                            if( pegObj.objectType == OBJECT_TYPE.MEMBER ) {
                                let pointA;

                                context.strokeStyle = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);
                                context.lineWidth = 1;
                                context.beginPath();
                                point = pegObj.origin.polarToAbsXY( obj.boundingRadius, pegObj.angle );
                                context.moveTo( point.x, point.y );
                                point = pegObj.origin.polarToAbsXY( obj.boundingRadius, pegObj.angle+120 );
                                context.lineTo( point.x, point.y );
                                point = pegObj.origin.polarToAbsXY( obj.boundingRadius, pegObj.angle+240 );
                                context.lineTo( point.x, point.y );
                                context.closePath();
                                context.stroke();
                                
                                context.beginPath();
                                point = pegObj.origin.polarToAbsXY( obj.boundingRadius/2, pegObj.angle+60 );
                                context.arc( point.x, point.y, obj.boundingRadius/2, 0, 2*Math.PI );
                                context.closePath();
                                context.stroke();

                                context.beginPath();
                                point = pegObj.origin.polarToAbsXY( obj.boundingRadius/2, pegObj.angle+180 );
                                context.arc( point.x, point.y, obj.boundingRadius/2, 0, 2*Math.PI );
                                context.closePath();
                                context.stroke();

                                context.beginPath();
                                point = pegObj.origin.polarToAbsXY( obj.boundingRadius/2, pegObj.angle-60 );
                                context.arc( point.x, point.y, obj.boundingRadius/2, 0, 2*Math.PI );
                                context.closePath();
                                context.stroke();
                            }
                        }
                    }
                    break;

                case TORUS_TREATMENT.FLOWER_OF_LIFE:
                    {
                        let centerArray = [];
                        let radius = Math.floor( obj.boundingRadius/3 );
                        let startColour = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);

                        iterateSacred( obj, radius, 0, 0, centerArray );
                        context.lineWidth = 1;
                        context.strokeStyle = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);
                        for( let j = 0; j < centerArray.length; ++j ) {
                            let point = obj.origin.absXY( centerArray[j].centerX, centerArray[j].centerY );

                            context.strokeStyle = pointColour( obj, point, startColour );
                            let visiblePoints = centerArray[j].visiblePoints;
                            for( let k = 0; k < visiblePoints.length; ++k ) {
                                let endIndex = (k+1) % visiblePoints.length;
                                if( visiblePoints[k] && visiblePoints[endIndex] ) {
                                    let startAngle = 2*Math.PI * k / visiblePoints.length;
                                    let endAngle = 2*Math.PI * endIndex / visiblePoints.length;
                                    context.beginPath();
                                    context.arc( point.x, point.y, radius, startAngle, endAngle );
                                    context.closePath();
                                    context.stroke();
                                }
                            }
                        }
                    }
                    break;

                case TORUS_TREATMENT.METATRONS_CUBE:
                    {
                        let radius = obj.boundingRadius/5;
                        let points = [];
                        let startColour = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);
                        let angleStep = 360 / 6;

                        points.push( {point:pegObj.origin.polarToAbsXY( 0, 0 ), colour:startColour} );
                        for( let r = 2*radius; r <= 4*radius; r += 2*radius ) {
                            for( let count = 0; count < 6; ++count ) {
                                let point = pegObj.origin.polarToAbsXY( radius, 90+count*angleStep );
                                points.push( {point:pegObj.origin.polarToAbsXY( r, 90+count*angleStep ), 
                                              colour:pointColour( obj, point, startColour )} );
                            }
                        }

                        context.lineWidth = 1;
                        for( let j = 0; j < points.length; ++j ) {
                            context.strokeStyle = points[j].colour;
                            context.beginPath();
                            context.arc( points[j].point.x, points[j].point.y, radius, 0, 2*Math.PI );
                            context.closePath();
                            context.stroke();
                        }

                        for( let j = 1; j < points.length; ++j ) {
                            for( let k = j+1; k < points.length; ++k ) {
                                let gradient = context.createLinearGradient( points[j].point.x, points[j].point.y,
                                                                             points[k].point.x, points[k].point.y );
                                gradient.addColorStop( 0, points[j].colour );
                                gradient.addColorStop( 1, points[k].colour );
                                context.strokeStyle = gradient;
                                context.beginPath();
                                context.moveTo( points[j].point.x, points[j].point.y );
                                context.lineTo( points[k].point.x, points[k].point.y );
                                context.closePath();
                                context.stroke();
                                context.fillStyle = null;
                            }
                        }
                    }
                    break;

                case TORUS_TREATMENT.DAISY:
                    {
                        let startColour = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);
                        let width = obj.boundingRadius / 6;
                         
                        for( let radius = width/2; radius < obj.boundingRadius; radius += width/2 ) {
                            for( let angle = 0; angle < 360; angle += 10 ) {
                                let center = obj.origin.polarToAbsXY( radius, angle );
                                let colour = pointColour( obj, center, startColour );
                                context.beginPath();
                                context.strokeStyle = colour;
                                context.arc( center.x, center.y, width/2, 0, 2*Math.PI );
                                context.closePath();
                                context.stroke();
                            }
                            width *= 2;
                        }
                    }
                    break;

                case TORUS_TREATMENT.PETALS:
                    {
                        let startColour = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);
                        for( let angle=0; angle < 360; angle+=20 ) {
                            let center = obj.origin.polarToAbsXY( obj.boundingRadius/2, angle );
                            context.beginPath();
                            context.strokeStyle = pointColour( obj, center, startColour );
                            context.ellipse( center.x, center.y, obj.boundingRadius/2, 20, 
                                             angle * Math.PI / 180, 2*Math.PI, false );
                            context.fillStyle = pointColour( obj, center, startColour, "rgba", 0.1 );
                            context.fill();
                            context.closePath();
                            context.stroke();
                        }
                    }
                    break;

                case TORUS_TREATMENT.GOLDEN_SPIRAL:
                    {
                        let startColour = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);
                        context.save();
                        context.beginPath();
                        context.arc( obj.centerX(), obj.centerY(), 
                                     obj.boundingRadius + 1, 0, 2*Math.PI );
                        context.clip();
                        context.stroke();

                        iterateSpiralRotate( context, obj, startColour );
                        context.restore();
                    }
                    break;

                case TORUS_TREATMENT.METATRON_2:
                    {
                        let startColour = colorFromID(g_RecipientFontDesc.torusTreatmentColorID);
                    
                        context.save();
                        context.translate( obj.centerX(), obj.centerY() );
                        metatron2( context, obj, startColour );
                        context.restore();
                    }
                    break;

                case -1:
                    {
                        var imageDesc = g_Images[$("tort").value];
                        var image = imageDesc.image;
                        if( image != undefined && image.complete ) {
                            let opacity = Math.max( getOpacity( colorFromID(g_RecipientFontDesc.torusTreatmentColorID) ),
                                                    5 );
                            context.save();
                            context.beginPath();
                            context.arc( obj.centerX(), obj.centerY(), 
                                         obj.boundingRadius + 1, 0, 2*Math.PI );
                            context.clip();
                            context.stroke();

                            context.globalAlpha = opacity/100;

                            let width = image.width;
                            let height = image.height;

                            switch( imageDesc.type ) {
                                case "clip":
                                    {
                                        let centerX = imageDesc.centerX || width/2;
                                        let centerY = imageDesc.centerY || height/2;
                                        let radius = Math.min( centerX, centerY, width-centerX, height-centerY );
                                        let scale = imageDesc.scale || 1;

                                        radius *= scale;

                                        context.drawImage( image,
                                                           centerX-radius,
                                                           centerY-radius,
                                                           radius*2,
                                                           radius*2,
                                                           obj.centerX() - obj.boundingRadius,
                                                           obj.centerY() - obj.boundingRadius,
                                                           obj.boundingRadius * 2,
                                                           obj.boundingRadius * 2 )
                                    }
                                    break;

                                case "center":
                                default:
                                    {
                                        let scale = 2 * obj.boundingRadius / Math.sqrt( width*width + height*height );
                                        let newWidth = Math.floor( scale * width );
                                        let newHeight = Math.floor( scale * height );

                                        context.drawImage( image,
                                                           obj.centerX() - newWidth/2,
                                                           obj.centerY() - newHeight/2,
                                                           newWidth,
                                                           newHeight );
                                    }
                                    break;
                            }

                            context.restore();
                        }
                    }
                    break;
            }

            // Draw the torus
            obj.drawCircle( {color:colorFromID(obj.fontDesc.torusColorID), 
                             width:parseInt( $("torw").value ),
                             treatment:parseInt( $("torlt").value ),
                             weaveColor:colorFromID(g_RecipientFontDesc.torusTreatmentColorID) } );

            // Draw the pegs
            for( let j = 0; j < pegs.length; ++j ) {
                drawPeg( context, pegs[j].x, pegs[j].y );
            }
        } else {
            if( g_Debug ) {
                obj.debugBoundingBox( obj.spacing );

                if( obj.objectType == OBJECT_TYPE.MEMBER || obj.objectType == OBJECT_TYPE.MASTER ) {
                    obj.debugMinMaxAngles();
                }
            }
        }

        obj.draw();

        if( g_Debug ) {
            obj.drawCircle( {color:obj.fontDesc.DebugColor} );
            obj.drawCircle( {color:obj.fontDesc.DebugColor, spacing:obj.spacing} );

            obj.debugBoundingBox( 0 );
        }
    }
}

function getOpacity( colour ) {
	// validate hex string
	let hex = String(colour).replace(/[^0-9a-f]/gi, '');
	if (hex.length < 6) {
		hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
	}
    var opacity = 255;

	for (i = 0; i < 3; i++) {
		c = parseInt(hex.substr(i*2,2), 16);
        if( c < opacity ) opacity = c;
    }
    return Math.floor( (255-opacity)*100 / 255 );
}

function pointColour( torusObj, point, startColour, method, opacity ) {
    let p0, p1, p2, maxDistance;

    if( torusObj.colourPoints == undefined ) {
        let radius = torusObj.boundingRadius * 0.75;
        torusObj.colourPoints = {};
        torusObj.colourPoints.p0 = torusObj.origin.polarToAbsXY( radius, 30 );
        torusObj.colourPoints.p1 = torusObj.origin.polarToAbsXY( radius, 150 );
        torusObj.colourPoints.p2 = torusObj.origin.polarToAbsXY( radius, 270 );
        torusObj.colourPoints.maxDistance = distancePoints(torusObj.colourPoints.p0, torusObj.colourPoints.p1);
    }
    p0 = torusObj.colourPoints.p0;
    p1 = torusObj.colourPoints.p1;
    p2 = torusObj.colourPoints.p2;
    maxDistance = torusObj.colourPoints.maxDistance;
    let arr = [Math.min( distancePoints(point, p0), maxDistance ),
               Math.min( distancePoints(point, p1), maxDistance ), 
               Math.min( distancePoints(point, p2), maxDistance )];
    let magnitude = arr[0] + arr[1] + arr[2];
    let percent = [ arr[0]/magnitude, 
                    arr[1]/magnitude,
                    arr[2]/magnitude ];
    let rgb = "", c, i;

	// validate hex string
	let hex = String(startColour).replace(/[^0-9a-f]/gi, '');
	if (hex.length < 6) {
		hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
	}

	// convert to decimal and change luminosity
    if( method != null ) {
        rgb = method + "(";
    } else {
        // hexadecimal color
        rgb = "#";
    }
	for (i = 0; i < 3; i++) {
		c = parseInt(hex.substr(i*2,2), 16);
        
        c = c + 2*256*(0.5-percent[i]);
		c = Math.round(Math.min(Math.max(0, c), 255));
        if( method != null ) {
            rgb += c.toString();
            if( i < 2 ) {
                rgb += ",";
            }
        } else {
            c = c.toString(16);
            rgb += ("00"+c).substr(c.length);
        }
	}
    if( method != null ) {
        if( opacity != null ) {
            rgb += "," + opacity.toString();
        }
        rgb += ")";
    }

	return rgb;
}

function colorLuminance(hex, lum) {
	// validate hex string
	hex = String(hex).replace(/[^0-9a-f]/gi, '');
	if (hex.length < 6) {
		hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
	}
	lum = lum || 0;

	// convert to decimal and change luminosity
	let rgb = "#", c, i;
	for (i = 0; i < 3; i++) {
		c = parseInt(hex.substr(i*2,2), 16);
		c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
		rgb += ("00"+c).substr(c.length);
	}

	return rgb;
}

function lastVisibleMember() {
    let lastVisible = g_Origin.maxMembers - 1;
    while( lastVisible >= 0 ) {
        if( $("p" + lastVisible).value !== "" ) {
            break;
        }
        --lastVisible;
    }
    return lastVisible;
}

function buildCanvas() {
    resetGlobals();
    g_Debug = $("_debug").checked;

    g_RecipientFontDesc.imageColor = g_Debug ? "yellow" : colorFromID("bgc");

    let tort = $("tort").value;
    if( !isNaN(tort) && isFinite(tort) ) {
        g_TorusTreament = parseInt(tort);
    } else {
        g_TorusTreament = -1;
    }
    g_PegTreatment = parseInt($("pegt").value);

    if( $("t1").value !== "" )   g_Title.push( $("t1").value );
    if( $("t2").value !== "" )   g_Title.push( $("t2").value );

    let lastVisible = lastVisibleMember();
    for( let i = 0; i < g_Origin.maxMembers; ++i ) {
        let member = $("p" + i).value;
        let master = $("m" + i).value;

        if( member !== "" ) {
            if( g_Members.length > 0 && member === g_Members[g_Members.length-1].member ) {
                g_Members[g_Members.length-1].master += " / " + master;
            } else {
                g_Members.push( {member:member, master:master} );
            }
        }

        if( i <= lastVisible ) {
            $("tr" + i).style.visibility = "visible";
        } else {
            $("tr" + i).style.visibility = "hidden";
        }
    }

    setDefaultFilename();

    g_Origin.memberStartAngle = parseInt( $("o").value );
    g_Origin.torusRingSize = parseInt( $("tors").value );
    g_Origin.torusRingPegSize = parseInt( $("pegw").value );
    if( g_Origin.torusRingSize < 100 || g_Origin.torusRingSize > 300 ) {
        g_Origin.torusRingSize = 100;
    }
    let result = createSeatingArrangement();
    if( result == null ) {
        $("_error").innerHTML = "";
        drawSeatingArrangement();
    } else {
        $("_error").innerHTML = result;
    }

    composeMyURL();
}

function newImage() {
    g_TorusImage = new Image;
    g_TorusImage.crossOrigin = "Anonymous";
    g_TorusImage.onload = function() { buildCanvas(); }
    g_TorusImage.src = $("tori").value;

    // make sure the load event fires for cached images too
    if( g_TorusImage.complete || g_TorusImage.complete === undefined ) {
        g_TorusImage.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
        g_TorusImage.src = $("tori").value;
    }
}

function testCORS() {
    let testImage = new Image;
    testImage.src = "http://maps.gstatic.com/mapfiles/api-3/images/google_white5.png";
    testImage.onload = function() {
        let canvas = $("_testCanvas");
        let context = canvas.getContext("2d");
        context.drawImage( testImage, 0, 0, 10, 10 ); 
    
        // Cross-Origin Resource Sharing (CORS) is a W3C specification that
        //  allows cross-domain communication from the browser.  Note that
        //  often cross-domain refers to resources that have different hostnames.
        //  When CORS isn't enabled, it prevents this program from including
        //  images to be embedded in the downloaded image (although they could
        //  still be rendered).  We'll detect this scenario and prevent images
        //  from being embedded.
        let violation = false;
        try {
            let junkHref = canvas.toDataURL("image/png");
        } catch( err ) {
            violation = true;
        }
        g_CORSEnabled = violation;
    }
}

function testOverlap() {
    for( let i = 1; i < g_ObjectArray.length; ++i ) {
        let obj = g_ObjectArray[i];

        if( obj.intersectsCircle( g_ObjectArray[0] ) ) {
            return "object '" + obj.getName() + "' intersects torus circle";
        }
    }
    
    for( let i = 0; i < g_ObjectArray.length; ++i ) {
        let obj = g_ObjectArray[i];
        if( obj.exceedsImageBoundary() ) {
            return "object '" + obj.getName() + "' exceeds image boundary";
        }

        for( let j = i+1; j < g_ObjectArray.length; ++j ) {
            let outerObj = g_ObjectArray[j];
            if( obj.intersectsBoundingBox( outerObj ) ) {
                return "object '" + obj.getName() + "' intersects with '" 
                        + outerObj.getName() + "'";
            }
        }
    }

    return null;    // no intersection
}

function distance( x1, y1, x2, y2 ) {
    return Math.sqrt( Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2) );
}

function distancePoints( p1, p2 ) {
    return distance( p1.x, p1.y, p2.x, p2.y );
}

function myTrim( str ) {
    return str.replace(/^\s+|\s+$/g,"");
}

function normalizeAngle( angle ) {
    if( angle < 0 ) {
        return 360 + (angle % 360);
    } else {
        return angle % 360;
    }
}

function createTextObject( objectType,
                           textArray, 
                           canvas, 
                           context,
                           fontDesc, 
                           alignment, 
                           origin, 
                           radius, 
                           angle, 
                           spacing ) {
    let obj = {};
    obj.objectType = objectType;
    obj.textArray = textArray;
    obj.canvas = canvas;
    obj.fontDesc = fontDesc;
    obj.alignment = alignment;
    obj.origin = origin;
    obj.radius = radius;
    obj.angle = normalizeAngle( angle );
    obj.spacing = spacing;

    obj.font = ($(fontDesc.fontItalicID).checked ? "italic" : "normal") + " "     // font style
             + ($(fontDesc.fontBoldID).checked ? "bold" : "normal") + " "         // font weight
             + $(fontDesc.fontSizeID).value + " " 
             + $(fontDesc.fontFamilyID).value;
    obj.shadowEnabled = $(fontDesc.fontShadowID).checked;
    obj.context = context;
    obj.context.font = obj.font;

    obj.line = [];
    let maxWidth = 0;
    for( let i = 0; i < textArray.length; ++i ) {
        let width = Math.round( obj.context.measureText( textArray[i].text ).width );
        obj.line.push( {'text':myTrim(textArray[i].text),
                        'width':width,
                        'color':textArray[i].color} );
        if( width > maxWidth ) maxWidth = width;
    }

    obj.fontHeight = parseInt($(fontDesc.fontSizeID).value);   // e.g. "14px"
    obj.boundingWidth = maxWidth;
    obj.boundingHeight = obj.fontHeight * textArray.length;

    obj.boxCenterX = Math.round( obj.boundingWidth / 2 );
    obj.boxCenterY = Math.round( obj.boundingHeight / 2 );
    obj.boundingRadius = distance( 0, 0, obj.boxCenterX, obj.boxCenterY );

    obj.adjustX = 0;
    obj.adjustY = 0;

    if( obj.objectType == OBJECT_TYPE.MEMBER ) {
        // Some fine placement is necessary for the member elements that
        //  immediately orbit the circle so that the member text is adjacent
        //  to the peg.
        let peg = obj.origin.polarToAbsXY( obj.origin.torusRingSize + obj.origin.torusRingPegSize,
                                           obj.angle ); 
        let center = obj.origin.polarToAbsXY( obj.radius, obj.angle );
        let top = center.y - obj.boxCenterY - obj.spacing;
        let bottom = top + obj.boundingHeight + obj.spacing;
        let left = center.x - obj.boxCenterX - obj.spacing;
        let right = left + obj.boundingWidth + obj.spacing;

        if( obj.angle == 0 || obj.angle == 90 || obj.angle == 180 || obj.angle == 270 ) {
            // this center is already correct
        } else if( obj.angle < 90 ) {
            // adjust to top left corner
            obj.adjustX = peg.x - left;
            obj.adjustY = peg.y - top;
        } else if( obj.angle < 180 ) {
            // adjust to top right corner
            obj.adjustX = peg.x - right;
            obj.adjustY = peg.y - top;
        } else if( obj.angle < 270 ) {
            // adjust to bottom right corner
            obj.adjustX = peg.x - right;
            obj.adjustY = peg.y - bottom;
        } else {
            // adjust to bottom left corner
            obj.adjustX = peg.x - left;
            obj.adjustY = peg.y - bottom;
        }
    }

    obj.toAbsXY = function() {
        let coord = this.origin.polarToAbsXY( this.radius, this.angle );
        coord.x += this.adjustX;
        coord.y += this.adjustY;
        return coord;
    };

    obj.centerX = function() {
        return this.toAbsXY().x;
    };

    obj.centerY = function() {
        return this.toAbsXY().y;
    };

    obj.left = function() {
        return this.centerX() - this.boxCenterX;
    };

    obj.top = function() {
        return this.centerY() - this.boxCenterY;
    };

    obj.right = function() {
        return this.left() + this.boundingWidth;
    };

    obj.bottom = function() {
        return this.top() + this.boundingHeight;
    };

    obj.computeAngle = function( x, y ) {
        let originCenter = this.origin.absXY( 0, 0 );
        let theta = Math.atan2( y - originCenter.y, x - originCenter.x ); 
        if( theta >= 0 ) {
            return theta / Math.PI * 180;
        } else {
            return (theta + 2*Math.PI) / Math.PI * 180;
        }
    };

    obj.computeMinAngle = function() {
        let top = this.top();
        let bottom = this.bottom();
        let left = this.left();
        let right = this.right();
        let leftTopAngle        = this.computeAngle(left, top);
        let rightTopAngle       = this.computeAngle(right, top);
        let rightBottomAngle    = this.computeAngle(right, bottom);
        let leftBottomAngle     = this.computeAngle(left, bottom);
        if( leftTopAngle > 270 && leftBottomAngle < 90 ) {  // straddles angle 0?
            return Math.min( leftTopAngle, rightTopAngle );
        } else {
            return Math.min( leftTopAngle, rightTopAngle, leftBottomAngle, rightBottomAngle );
        } 
    };

    obj.computeMaxAngle = function() {
        let top = this.top();
        let bottom = this.bottom();
        let left = this.left();
        let right = this.right();
        let leftTopAngle        = this.computeAngle(left, top);
        let rightTopAngle       = this.computeAngle(right, top);
        let rightBottomAngle    = this.computeAngle(right, bottom);
        let leftBottomAngle     = this.computeAngle(left, bottom);
        if( leftTopAngle > 270 && leftBottomAngle < 90 ) {  // straddles angle 0?
            return Math.max( leftBottomAngle, rightBottomAngle );
        } else {
            return Math.max( leftTopAngle, rightTopAngle, leftBottomAngle, rightBottomAngle );
        } 
    };

    obj.setRadius = function( radius ) {
        this.radius = radius;
    };

    obj.setBoundingRadius = function( boundingRadius ) {
        this.boundingRadius = boundingRadius;
    };

    obj.setAngle = function( angle ) {
        this.angle = normalizeAngle( angle );
    };
   
    obj.getName = function() {
        let str = "";
        for( let i = 0; i < this.textArray.length; ++i ) {
            str = str + " " + this.textArray[i].text;
        }
        return myTrim(str);
    }

    obj.draw = function() {
        let center = this.toAbsXY();
        let y = center.y - ((this.line.length - 1)*this.fontHeight) / 2;
        this.context.textBaseline = "middle";
        for( let i = 0; i < this.line.length; ++i ) {
            let line = this.line[i];
            let x;
            if( this.alignment == ALIGNMENT.LEFT ) {
                this.context.textAlign = "left";
                x = center.x - this.boxCenterX;
            } else if( this.alignment == ALIGNMENT.CENTER ) {
                this.context.textAlign = "center";
                x = center.x;
            } else if( this.alignment == ALIGNMENT.RIGHT ) {
                this.context.textAlign = "right";
                x = center.x + this.boxCenterX;
            } else {    // assume ALIGNMENT.AUTO
                // Choose the text alignment based on the angle.
                if( angle <= 45 || angle >= 315 ) {
                    this.context.textAlign = "left";
                    x = center.x - this.boxCenterX;
                } else if( angle >= 135 && angle <= 225 ) {
                    this.context.textAlign = "right";
                    x = center.x + this.boxCenterX;
                } else {
                    this.context.textAlign = "center";
                    x = center.x;
                }
            }
            this.context.font = this.font;
            if( this.shadowEnabled ) {
                // Create a shadow effect for the text
                shadow = colorLuminance( this.line[i].color || colorFromID(this.fontDesc.textColorID),
                                         -0.1 ); 
                this.context.shadowColor = shadow;
                this.context.shadowBlur = 10;
                this.context.lineWidth = 1; 
                this.context.strokeText( this.line[i].text, x, y );
                this.context.shadowBlur = 0; 
            }
            this.context.fillStyle = this.line[i].color || colorFromID(this.fontDesc.textColorID);
            this.context.fillText( this.line[i].text, x, y );
            y = y + this.fontHeight;
        }
    };

    obj.drawCircle = function( args ) {
        let context = this.context;

        context.fillStyle = args.fillColour;
        context.lineWidth = args.width || 1;

        var step = 2;
        var radius = this.boundingRadius + (args.spacing || 0) + 1;
        var ripple = 0;
        var rippleStep = 60;

        if( args.treatment == CIRCLE_TREATMENT.RIPPLE ) {
            ripple = 0;
            context.beginPath();
            context.strokeStyle = args.weaveColor || "#000000";
            for( var angle=0; angle<=360; angle += step ) {
                var r = radius;

                if( args.treatment == CIRCLE_TREATMENT.RIPPLE ) {
                    r = Math.sin( ripple * Math.PI/180 );
                    r = 3*r + radius;
                }
                var x2 = this.centerX() + r * Math.cos( angle * Math.PI/180 );
                var y2 = this.centerY() + r * Math.sin( angle * Math.PI/180 );

                if( angle == 0 ) {
                    context.moveTo( x2, y2 );
                } else {
                    context.lineTo( x2, y2 );
                }

                ripple += rippleStep;
            }
            context.stroke();
        }

        context.beginPath();
        context.strokeStyle = args.color || this.fontDesc.debugColor;
        for( var angle=0; angle<=360; angle += step ) {
            var r = radius;

            if( args.treatment == CIRCLE_TREATMENT.WAVE || args.treatment == CIRCLE_TREATMENT.RIPPLE ) {
                r = radius + 3 * Math.cos( ripple * Math.PI/180 );
            }
            var x1 = this.centerX() + r * Math.cos( angle * Math.PI/180 );
            var y1 = this.centerY() + r * Math.sin( angle * Math.PI/180 );

            if( angle == 0 ) {
                context.moveTo( x1, y1 );
            } else {
                context.lineTo( x1, y1 );
            }

            ripple += rippleStep;
        }
        context.stroke();

    };

    obj.debugBoundingBox = function( spacing ) {
        let context = this.context;
        context.strokeStyle = this.fontDesc.debugColor;
        context.lineWidth = 1;
        context.beginPath();
        context.moveTo( this.left()-spacing, this.top()-spacing );
        context.lineTo( this.right()+spacing, this.top()-spacing );
        context.lineTo( this.right()+spacing, this.bottom()+spacing );
        context.lineTo( this.left()-spacing, this.bottom()+spacing );
        context.closePath();
        context.stroke();
    };

    obj.debugMinMaxAngles = function() {
        let context = this.context;
        let torusCenter = this.origin.polarToAbsXY( 0, 0 );
        let minPoint = this.origin.polarToAbsXY( 300, this.computeMinAngle() );
        let maxPoint = this.origin.polarToAbsXY( 300, this.computeMaxAngle() );

        context.strokeStyle = "blue";
        context.lineWidth = 1;
        context.beginPath();
        context.moveTo( torusCenter.x, torusCenter.y );
        context.lineTo( minPoint.x, minPoint.y );
        context.stroke();
        context.strokeStyle = "red";
        context.beginPath();
        context.moveTo( torusCenter.x, torusCenter.y );
        context.lineTo( maxPoint.x, maxPoint.y );
        context.stroke();
    };

    obj.exceedsImageBoundary = function() {
        return this.left() < 0
            || this.right() >= obj.origin.imageWidth
            || this.top() < 0
            || this.bottom() >= obj.origin.imageHeight;
    };

    obj.intersectsBoundingBox = function( obj ) {
        return (this.left()-this.spacing <= obj.right()+obj.spacing)
            && (obj.left()-obj.spacing   <= this.right()+this.spacing)
            && (this.top()-this.spacing  <= obj.bottom()+obj.spacing)
            && (obj.top()-obj.spacing    <= this.bottom()+this.spacing);
    };

    obj.distanceToXY = function( x, y ) {
        return distance( this.centerX(), this.centerY(), x, y );
    };

    obj.intersectsCircle = function( obj ) {
        let left = this.left()-this.spacing;
        let top = this.top()-this.spacing;
        let right = this.right()+this.spacing;
        let bottom = this.bottom()+this.spacing;
        let minRadius = obj.boundingRadius + this.spacing;
        let objCenterX = obj.centerX();
        let objCenterY = obj.centerY();

        // Check if any of the bounding corners (plus spacing) fall within
        //  the object's circle.
        if( obj.distanceToXY( left, top ) < minRadius
         || obj.distanceToXY( right, top ) < minRadius
         || obj.distanceToXY( right, bottom ) < minRadius
         || obj.distanceToXY( left, bottom ) < minRadius ) {
            return true;
        }

        // Check if the top/bottom of the bounding box intersects with
        //  the object's circle.
        if( left < objCenterX && right > objCenterX 
         && (Math.abs( top-objCenterY ) < minRadius
             || Math.abs( bottom-objCenterY ) < minRadius) ) {
            return true;
        }

        // Check if the left/right of the bounding box intersects with
        //  the object's circle.
        if( top < objCenterY && bottom > objCenterY
         && (Math.abs( left-objCenterX ) < minRadius
             || Math.abs( right-objCenterX ) < minRadius) ) {
            return true;
        }

        return false;
    };

    return obj;
}

function getNumberStringPrefix( num ) {
    // determine 'st', 'nd', or 'rd', or 'th' prefix
    if( num <= 20 ) {
        if( num == 1 ) {
            return "st";
        } else if( num == 2 ) {
            return "nd";
        } else if( num == 3 ) {
            return "rd";
        } else {
            return "th";
        }
    } else {
        num = num % 10;

        if( num == 1 ) {
            return "st";
        } else if( num == 2 ) {
            return "nd";
        } else if( num == 3 ) {
            return "rd";
        } else {
            return "th";
        }
    }
}

function getDateString() {
    let day = new Date();
    let monthNames = ["January", "February", "March", "April", "May", "June", 
                      "July", "August", "September", "October", "November", "December"];
    let currentMonth = day.getUTCMonth();
    let str = monthNames[day.getUTCMonth()] + " " + day.getUTCDate() + getNumberStringPrefix( day.getUTCDate() ) + "/";

    // advance to 'tomorrow'
    day.setTime( day.getTime() + 86400 * 1000 );

    if( currentMonth == day.getUTCMonth() ) {
        // In current month.
        return str + day.getUTCDate() + getNumberStringPrefix( day.getUTCDate() );
    } else {
        return str + monthNames[day.getUTCMonth()] + " " + day.getUTCDate() + getNumberStringPrefix( day.getUTCDate() );
    }
}

function setDefaultFilename() {
    let day = new Date();
    let shortMonthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

    // NOTE: This may be a bit annoying to create the default filename based on the group title.
    //       We'll see how it goes.
    $("f").value = $("t1").value + " - " + 
                   shortMonthNames[day.getMonth()] + " " + day.getDate() + ", " + day.getFullYear() + ".png";

}

function getProfiles() {
    let profiles = [];
    for( let i = 0; i < g_Origin.maxProfiles; ++i ) {
        let cookie = getCookie( "profile"+i );
        if( cookie != null ) {
            let url = new Url( "?" + cookie );
            profiles.push( url.query );
        }
    }
    return profiles;
}

function setProfiles() {
    let u = getUrlWithParameters();
    let profiles = getProfiles();
    let found = false;

    u.query["day"] = (new Date()).getDay();
    for( let i = 0; i < profiles.length; ++i ) {
        if( profiles[i]["t1"] === u.query["t1"] ) {
            // found the profiles with the same title. Update it
            //  and move it to the top of the list.
            profiles.splice( i, 1 );         // remove old object
            profiles.splice( 0, 0, u.query );   // insert replacement
            found = true;
            break;
        }
    }

    if( !found ) {
        // add the object to the start of the list
        profiles.unshift( u.query );
        // possibly remove the extra entry
        if( profiles.length >= g_Origin.maxProfiles ) {
            profiles.splice( g_Origin.maxProfiles, profiles.length );
        }
    }

    for( let i = 0; i < profiles.length && i < g_Origin.maxProfiles; ++i ) {
        setCookie( "profile"+i, profiles[i].toString(), g_Origin.maxCookieDays );
    }
}

function selectProfile() {
    let profiles = getProfiles();
    let num = parseInt($("profile").value);

    // Set default element values
    initializeElementsFromHash( g_ElementDefaults );

    // Set values to selected profile.
    if( num >= 0 && num < profiles.length ) {
        initializeElementsFromHash( profiles[num] );
    }

    buildCanvas();
}

function saveProfile() {
    setProfiles();
    createProfilesElement( "profiles" );
}

function createProfilesElement( parentID ) {
    let weekDays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    let profiles = getProfiles();
    let current = $("t1").value;
    let str = "<select class=dropDown name=profile id=profile onChange='selectProfile()'>\n";
    str += "<option value='-1'>Default</option>\n";
    for( let i = 0; i < profiles.length; ++i ) {
        str += "<option value='" + i + "'";
        if( profiles[i]["t1"] === current ) {
            str += " selected";
        } 
        str += ">" + profiles[i]["t1"];
        let day = profiles[i]["day"];
        if( weekDays[day] != undefined ) {
            str += " ("+weekDays[day]+")";
        }
        str += "</option>\n";
    }
    str += "</select>";
    let element = document.createElement( "span" );
    element.innerHTML = str;

    let last = $(parentID).lastChild;
    if( last != null ) {
        $(parentID).removeChild( last );
    }
    $(parentID).appendChild( element );
}

function createFontSelectionElements( parentID, fontDesc ) {
    let fontWeights = [ "normal", "bold" ];
    let fontSizes = [ "10px", "12px", "14px", "16px", "18px", "20px", "22px" ];

    let fontStyles = [ "normal", "italic" ];

    // font family selection
    let element = document.createElement( "span" );
    let str = "<select class=dropDown name=fontFamily id='" + fontDesc.fontFamilyID + "' onchange='buildCanvas()'>\n";
    for( let i = 0; i < g_DetectedFonts.length; ++i ) {
        str += "<option value='" + g_DetectedFonts[i] + "'";
        str += ">" + g_DetectedFonts[i] + "</option>\n";
    }
    str += "</select> ";
    element.innerHTML = str;
    $(parentID).appendChild( element );

    // font size selection
    element = document.createElement( "span" );
    str = "<select class=dropDown name=fontSize id='" + fontDesc.fontSizeID + "' onchange='buildCanvas()'>\n";
    for( let i = 0; i < fontSizes.length; ++i ) {
        str += "<option value='" + fontSizes[i] + "'";
        str += ">" + fontSizes[i] + "</option>\n";
    }
    str += "</select> ";
    element.innerHTML = str;
    $(parentID).appendChild( element );

    // font bold selection
    element = document.createElement( "span" );
    str = "<B>Bold</B><input type=checkbox id='" + fontDesc.fontBoldID + "' onchange='buildCanvas()'>\n";
    element.innerHTML = str;
    $(parentID).appendChild( element );

    // font italic selection
    element = document.createElement( "span" );
    str = "<I>Italic</I><input type=checkbox id='" + fontDesc.fontItalicID + "' onchange='buildCanvas()'>\n";
    element.innerHTML = str;
    $(parentID).appendChild( element );

    // font shadow selection
    element = document.createElement( "span" );
    str = "<U>Shadow</U><input type=checkbox id='" + fontDesc.fontShadowID + "' onchange='buildCanvas()'>\n";
    element.innerHTML = str;
    $(parentID).appendChild( element );
}

function initializeElementsFromHash( hash ) {
    let all = document.getElementsByTagName("*");
    for( let i = 0; i < all.length; ++i ) {
        let el = all[i];
        if( hash[el.id] != undefined ) {
            let defaultValue = hash[el.id];

            if( el.nodeName === "SELECT" ) {
                el.value = defaultValue;
            } else if( el.nodeName === "INPUT" ) {
                if( el.type.toLowerCase() === "checkbox" ) {
                    el.checked = (defaultValue === "true");
                } else if( el.type.toLowerCase()==="select-one" ) {
                    el.value = defaultValue;
                } else if( el.type.toLowerCase()==="text") {
                    el.value = defaultValue;

                    // For jscolor class elements, update the text box background color.
                    if( el.className === "jscolor" ) {
                        // jscolor class element
                        el.jscolor.importColor();
                    }
                }
            }
        }
    }
}

function setParametersFromUrl( url ) {
    let u = new Url( url );

    initializeElementsFromHash( u.query );
}

function getUrlWithParameters() {
    let url = new Url();
    let all = document.getElementsByTagName("*");
    let hash = g_ElementDefaults;

    url.clearQuery();   // remove all query string parameters
    for( let i = 0; i < all.length; ++i ) {
        let el = all[i];

        if( hash[el.id] != undefined ) {
            let defaultValue = hash[el.id];

            if( el.nodeName === "SELECT" ) {
                if( el.value !== defaultValue ) {
                    url.query[el.id] = el.value;
                }
            } else if( el.nodeName === "INPUT" ) {
                if( el.type.toLowerCase() === "checkbox" ) {
                    if( el.checked != defaultValue ) {
                        url.query[el.id] = el.checked;
                    }
                } else if( el.type.toLowerCase()==="select-one"
                        || el.type.toLowerCase()==="text" ) {
                    if( el.value !== defaultValue ) {
                        url.query[el.id] = el.value;
                    }
                }
            }
        }
    }
    return url;
}

function composeMyURL() {
    let url = getUrlWithParameters();
    $("_myURL").innerHTML = "<b>" + url + "</b>";
}

function setCookie( name, value, days ) {
    let expires = "";
    if (days) {
        let date = new Date();
        date.setTime(date.getTime() + (days*24*60*60*1000));
        expires = "; expires=" + date.toUTCString();
    }
    document.cookie = name + "=" + (value || "")  + expires + "; path=/";
}

function getCookie( name ) {
    let nameEQ = name + "=";
    let ca = document.cookie.split(';');
    for(let i=0;i < ca.length;i++) {
        let c = ca[i];
        while (c.charAt(0)==' ') c = c.substring(1,c.length);
        if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
    }
    return null;
}

function eraseCookie( name ) {   
    document.cookie = name+'=; Max-Age=-99999999;';  
}

function deleteRow( num ) {
    if( num <= lastVisibleMember() ) {
        while( num < g_Origin.maxMembers-1 ) {
            $("p"+num).value = $("p"+(num+1)).value;
            $("m"+num).value = $("m"+(num+1)).value;
            ++num;
        }
        $("p"+num).value = "";
        $("m"+num).value = "";
        buildCanvas();
    }
}

function memberHandleDragStart(e) {
    this.style.opacity = '0.4';  // this / e.target is the source node.
    g_DragSrcEl = this;

    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData( "text/html", this.innerHTML);
}

function memberHandleDragOver(e) {
    if (e.preventDefault) {
        e.preventDefault(); // Necessary. Allows us to drop.
    }

    e.dataTransfer.dropEffect = 'move';  // See the section on the DataTransfer object.
    return false;
}

function memberHandleDragEnter(e) {
    // this / e.target is the current hover target.
    this.classList.add('over');
}

function memberHandleDragLeave(e) {
    this.classList.remove('over');  // this / e.target is previous target element.
}

function memberHandleDrop(e) {
    // this / e.target is current target element.

    if (e.stopPropagation) {
        e.stopPropagation(); // stops the browser from redirecting.
    }

    if( g_DragSrcEl != this ) {
        let srcRow = parseInt( g_DragSrcEl.id );
        let destRow = parseInt( this.id );
        let tempName = $("p"+srcRow).value;
        let tempMaster = $("m"+srcRow).value;

        if( destRow > srcRow ) {
            while( srcRow < destRow ) {
                $("p"+srcRow).value = $("p"+(srcRow+1)).value;
                $("m"+srcRow).value = $("m"+(srcRow+1)).value;
                ++srcRow;
            }
            $("p"+srcRow).value = tempName;
            $("m"+srcRow).value = tempMaster;
        } else {
            while( srcRow > destRow ) {
                $("p"+srcRow).value = $("p"+(srcRow-1)).value;
                $("m"+srcRow).value = $("m"+(srcRow-1)).value;
                --srcRow;
            }
        }
        $("p"+srcRow).value = tempName;
        $("m"+srcRow).value = tempMaster;
        buildCanvas();
    }

    let rows = document.querySelectorAll('#members .row');
    [].forEach.call(rows, function (row) {
        row.classList.remove('over');
        row.style.opacity = "";
    });

    return false;
}

function memberHandleDragEnd(e) {
    // this/e.target is the source node.

    let rows = document.querySelectorAll('#members .row');
    [].forEach.call(rows, function (row) {
        row.classList.remove('over');
        row.style.opacity = "";
    });
}

function imageHandleDrop(e) {
    // this / e.target is current target element.

    if (e.preventDefault) {
        e.preventDefault(); // Necessary. Allows us to drop.
    }

    if (e.stopPropagation) {
        e.stopPropagation(); // stops the browser from redirecting.
    }

    let url = e.dataTransfer.getData( "URL" );
    if( url ) {
        // If an image is being drag-and-drop'd then set the image treatment immediately.
        $("tori").value = url;
        $("tort").value = TORUS_TREATMENT.IMAGE;
        newImage();
    }
    return false;
}

function cancel(e) {
    if (e.preventDefault) {
        e.preventDefault(); // Necessary. Allows us to drop.
    }
    return false;
}

function addEventHandler(obj, evt, handler) {
    if(obj.addEventListener) {
        // W3C method
        obj.addEventListener(evt, handler, false);
    } else if(obj.attachEvent) {
        // IE method.
        obj.attachEvent('on'+evt, handler);
    } else {
        // Old school method.
        obj['on'+evt] = handler;
    }
}

function saveMembers() {
    for( let i = 0; i < g_Origin.maxMembers; ++i ) {
        let member = $("p" + i).value;
        if( member !== "" ) {
            let found = false;

            for( let j = 0; j < g_AllMembers.length; ++j ) {
                if( member === g_AllMembers[j] ) {
                    // Found the member in the list.  Update it and move
                    //  it to the top of the list.
                    g_AllMembers.splice( j, 1 );            // remove the old entry
                    g_AllMembers.splice( 0, 0, member );    // insert replacement
                    found = true;
                    break;
                }
            }

            if( !found ) {
                // Add the member to the start of the list.
                g_AllMembers.unshift( member );
                if( g_AllMembers.length >= g_Origin.maxDropDownMembers ) {
                    g_AllMembers.splice( g_Origin.maxDropDownMembers,
                                         g_Origin.length );
                }
            }
        }
    }
    setCookie( "membersList", g_AllMembers.join( "/" ) );
}

function loadMembers() {
    let cookie = getCookie( "membersList" );

    if( cookie == null ) {
        g_AllMembers = [];
    } else {
        g_AllMembers = cookie.split( "/" );
    }

    let element = document.createElement( "datalist" );
    let str = "";
    element.setAttribute( "id", "membersList" );
    for( let i = 0; i < g_AllMembers.length; ++i ) {
        str += "<option value='" + g_AllMembers[i] + "'>\n";
    }
    element.innerHTML = str;

    let last = $("membersDatalist").lastChild;
    if( last != null ) {
        $("membersDatalist").removeChild( last );
    }
    $("membersDatalist").appendChild( element );
}

function pageSetup() {
    // Determine what fonts are supported.
    g_DetectedFonts = (new Detector()).identifyCommonFonts();

    testCORS();

    // Update the canvas to configured dimensions.
    let canvas = $("_canvas");
    canvas.width = g_Origin.imageWidth;
    canvas.height = g_Origin.imageHeight;
    addEventHandler( canvas, "dragover", cancel );
    addEventHandler( canvas, "dragenter", cancel );
    addEventHandler( canvas, "drop", imageHandleDrop );

    createFontSelectionElements( "titleProperties", g_TitleFontDesc );
    createFontSelectionElements( "recipientProperties", g_RecipientFontDesc );
    createFontSelectionElements( "memberProperties", g_MemberFontDesc );
    createFontSelectionElements( "masterProperties", g_MasterFontDesc );

    // Create the Members/Masters forms.
    for( let i = 0; i < g_Origin.maxMembers; ++i ) {
       let element = document.createElement( "div" );
       element.setAttribute( "class", "row" );
       element.setAttribute( "draggable", "true" );
       element.setAttribute( "id", "" + i );
       let str = "<span class='tooltip' id='tr" + i + "' onClick='deleteRow(" + i + ")'>&#9949;" +
                 "<span class='tooltiptext'>Delete this row</span></span> " +
                "Member <input class=textInput type='text' name='member' id='p" + i + "' list=membersList" +
                 " onChange='buildCanvas()'/>" +
                 " works with <select class=dropDown name=masters id='m" + i + "' onChange='buildCanvas()'>\n";

       g_MastersList.sort();
       for( let j = 0; j < g_MastersList.length; ++j ) {
           let name = g_MastersList[j].toUpperCase();
           str += "<option value=\"" + name + "\">" + name + "</option>\n";
       }
       str += "</select>";
       element.innerHTML = str;

       $("members").appendChild( element );
    }

    // Populate the date in the title.
    $("t2").value = getDateString() + "    Duration: 20 min";

    // Update the "Download image" anchor element to download the canvas as a PNG file.
    let dl = $("downloadLink");
    addEventHandler( dl,
                     "click", 
                     function() { 
                         saveMembers();
                         loadMembers();
                         this.href = _canvas.toDataURL("image/png");
                         let name = $("f").value;
                         if( name === "" ) name = "image.png";
                         this.download = name;
                     } );

    // Support for draggable elements.
    let rows = document.querySelectorAll('#members .row');
    [].forEach.call(rows, function(row) {
      addEventHandler( row, 'dragstart', memberHandleDragStart );
      addEventHandler( row, 'dragenter', memberHandleDragEnter );
      addEventHandler( row, 'dragover', memberHandleDragOver );
      addEventHandler( row, 'dragleave', memberHandleDragLeave );
      addEventHandler( row, 'drop', memberHandleDrop );
      addEventHandler( row, 'dragend', memberHandleDragEnd );
    });

    if( g_CORSEnabled ) {
        // If CORS is enabled then prevent image URLs being enterred.
        $("_imageInput").style.display = "none";
    }

    // Set default element values
    initializeElementsFromHash( g_ElementDefaults );

    if( window.location.href.indexOf( "?" ) != -1 ) {
        // Set element values from URL parameters
        setParametersFromUrl( window.location.href );
    } else {
        let profiles = getProfiles();
        let day = (new Date()).getDay();

        // Try to find the last profile created on this weekday
        for( let i = 0; i < profiles.length; ++i ) {
            if( parseInt(profiles[i]["day"]) == day ) {
                // Set values to selected profile.
                initializeElementsFromHash( profiles[i] );
                break;
            }
        }
    }

    createProfilesElement( "profiles" );
    loadMembers();

    let option = document.createElement( "option" );
    option.setAttribute( "style", "font-size: 1pt; background-color: #000000;" );
    option.setAttribute( "disabled", "" );
    option.innerHTML = "&nbsp;";
    $("tort").appendChild( option );
    
    for( var im in g_Images ) {
        var imageDesc = g_Images[im];

        option = document.createElement( "option" );
        option.setAttribute( "value", im );
        option.innerHTML = "Picture '" + im + "'";
        $("tort").appendChild( option );

        imageDesc.image = new Image;
        imageDesc.image.src = imageDesc.file;
    }

    var canvasEl = $("_canvas");
    
    //$("tort").value = "11";  // XXX REMOVE

    buildCanvas();
}

//
//////////////////////////////////////////////////////

  </script>
</head>
  <style>
    /* Prevent the text contents of draggable elements from being selectable. */
    [draggable] {
      -moz-user-select: none;
      -khtml-user-select: none;
      -webkit-user-select: none;
      user-select: none;
      /* Required to make elements draggable in old WebKit */
      -khtml-user-drag: element;
      -webkit-user-drag: element;
    }
    .dropDown {
      background-color: #FFE2E1
    }
    .textInput {
      background-color: #E2DDED;
    }
    .row {
      border: 2px solid #666666;
      background-color: #ccc;
      margin-right: 5px;
      -webkit-border-radius: 10px;
      -ms-border-radius: 10px;
      -moz-border-radius: 10px;
      border-radius: 10px;
      -webkit-box-shadow: inset 0 0 3px #000;
      -ms-box-shadow: inset 0 0 3px #000;
      box-shadow: inset 0 0 3px #000;
      text-align: center;
      cursor: move;
    }
    .row header {
      color: #fff;
      text-shadow: #000 0 1px;
      box-shadow: 5px;
      padding: 5px;
      background: -moz-linear-gradient(left center, rgb(0,0,0), rgb(79,79,79), rgb(21,21,21));
      background: -webkit-gradient(linear, left top, right top,
                                   color-stop(0, rgb(0,0,0)),
                                   color-stop(0.50, rgb(79,79,79)),
                                   color-stop(1, rgb(21,21,21)));
      background: -webkit-linear-gradient(left center, rgb(0,0,0), rgb(79,79,79), rgb(21,21,21));
      background: -ms-linear-gradient(left center, rgb(0,0,0), rgb(79,79,79), rgb(21,21,21));
      border-bottom: 1px solid #ddd;
      -webkit-border-top-left-radius: 10px;
      -moz-border-radius-topleft: 10px;
      -ms-border-radius-topleft: 10px;
      border-top-left-radius: 10px;
      -webkit-border-top-right-radius: 10px;
      -ms-border-top-right-radius: 10px;
      -moz-border-radius-topright: 10px;
      border-top-right-radius: 10px;
    }
    .row.over {
      border: 2px dashed #000;
    }
    .inputTable {
      border: 4px solid red;
      border-radius: 20px;
      padding: 10px;
    }
    .imageTable {
      border: 2px solid green;
    }
    .tooltip {
        position: relative;
        display: inline-block;
        border-bottom: 1px dotted black;
    }
    .tooltip .tooltiptext {
        visibility: hidden;
        width: 150px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 6px;
        padding: 5px 0;
        position: absolute;
        z-index: 1;
        top: 150%;
        left: 50%;
        margin-left: -60px;
        
        /* Fade in tooltip - takes 1 second to go from 0% to 100% opac: */
        opacity: 0;
        transition: opacity 1s;
    }
    .tooltip .tooltiptext::after {
        content: "";
        position: absolute;
        bottom: 100%;
        left: 50%;
        margin-left: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: transparent transparent black transparent;
    }
    .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
    }
  </style>
  <body onLoad=pageSetup()>
    <script src="jscolor.min.js"></script>
    <script src="jsurl.js"></script>
    Click <a href=help.html>here</a> for help.
    <a id="downloadLink" href="#image">Download</a> image as filename
    <input class=textInput type='text' name="name" id="f" value="download.png" size="60"/><br>
    Profiles: <span id='profiles'></span> <span class='tooltip'><button type='button' onclick='saveProfile()'>Save profile</button><span class=tooltiptext>Save current settings profile</span></span>
    
    <div id="membersDatalist"></div>

    <table class='inputTable'>
      <tr>
        <td>
        <h2>Group Torus Title</h2>
        Title 1: <span class='tooltip'><input class=textInput type='text' name='t1' id='t1' size='40' value='' onChange='buildCanvas()'><span class='tooltiptext'>Title used in the image header and download filename.</span></input></span><br>
        Title 2: <input class=textInput type='text' name='t2' id='t2' size='40' value='Duration: 20 min' onChange='buildCanvas()'/><br>
        part (optional) <input class=textInput type='text' name='tp' id='tp' size='20' value='' onChange='buildCanvas()'/>
            <span class='tooltip'><input class="jscolor" id='tpc' value="000000" size='4' onchange='buildCanvas()'><span class='tooltiptext'>Colour selector for<br/><b>part (optional)</b></span></span> <br>
        Font <span id='titleProperties'></span>
            <span class='tooltip'><input class="jscolor" id='tc' value="000000" size='4' onchange='buildCanvas()'><span class='tooltiptext'>Colour selector for<br/><b>Title 1</b> and <b>Title 2</b></span></span><br>

        <h2>Members / Masters</h2>
        <i><b>Members are added to the torus in a <select class=dropDown name=order id=or onchange='buildCanvas()'>
            <option value='counter'>counter-clockwise</option>
            <option value='clockwise'>clockwise</option>
        </select> order.   Masters are on the<br> right (counter-clockwise) of members.<br></b></i>
        <div id="members"></div>

        <p id="_error"></p>

        Member font <span id='memberProperties'></span>
            <span class='tooltip'><input class="jscolor" id='pc' value="000000" size='4' onchange='buildCanvas()'><span class='tooltiptext'>Colour selector for <br/>member names.</span></span> <br>
        Master font <span id='masterProperties'></span>
            <span class='tooltip'><input class="jscolor" id='mc' value="000000" size='4' onchange='buildCanvas()'><span class='tooltiptext'>Colour selector for<br/>master names.</span></span> <br>
        Orientation for first member is
        <select class=dropDown name=orientation id=o onChange='buildCanvas()'>
            <option value=270>North (N)</option>
            <option value=292.5>North-Northeast (NNE)</option>
            <option value=315>Northeast (NE)</option>
            <option value=337.5>East-Northeast (ENE)</option>
            <option value=0>East (E)</option>
            <option value=22.5>East-Southeast (ESE)</option>
            <option value=45>Southeast (SE)</option>
            <option value=67.5>South-Southeast (SSE)</option>
            <option value=90>South (S)</option>
            <option value=112.5>South-Southwest (SSW)</option>
            <option value=135>Southwest (SW)</option>
            <option value=157.5>West-Southwest (WSW)</option>
            <option value=180>West (W)</option>
            <option value=202.5>West-Northwest (WNW)</option>
            <option value=225>Northwest (NW)</option>
            <option value=247.5>North-Northwest (NNW)</option>
        </select>
        <div/>
        <br/>
        <h2>Torus Circle</h2>
        <table border=0>
          <tr>
            <td>Background colour:</td>
            <td><input class="jscolor" id='bgc' value="FFFFFF" size='6' onchange='buildCanvas()'></td>
          </tr><tr>
            <td>Torus circle</td>
            <td>
              <table border=1>
                <tr>
                  <td>circle treatment:</td>
                  <td>
                    <span class=tooltip>
                      <select class=dropDown name=torusTreatment id='tort' onChange='buildCanvas()'>
                        <option value=0>None</option>
                        <option value=1>HEART</option>
                        <option value=2>RANDOM</option>
                        <option value=3>FLOWER_OF_LIFE</option>
                        <option value=4>METATRONS_CUBE</option>
                        <option value=5>DAISY</option>
                        <option value=6>PETALS</option>
                        <option value=10>GOLDEN_SPIRAL</option>
                        <option value=11>METATRON_2</option>
                        <option value=7>MESH (per members)</option>
                        <option value=8>GEOMETRIC_1 (per members)</option>
                        <option value=9>IMAGE</option>
                      </select>
                      <span class=tooltiptext>Pattern to display within torus circle</span>
                    </span>
                    <span class=tooltip>
                      <input class="jscolor" id='tortc' value="000000" size='6' onchange='buildCanvas()'> <br>
                      <span class=tooltiptext>Colour selector for pattern in torus</span>
                    </span>
                   </td>
                </tr><tr>
                  <td>circle size:</td>
                  <td>
                    <select class=dropDown name=torusSize id='tors' onChange='buildCanvas()'>
                      <option value=100>100px</option>
                      <option value=110>110px</option>
                      <option value=120>120px</option>
                      <option value=130>130px</option>
                      <option value=140>140px</option>
                      <option value=150>150px</option>
                    </select>
                  </td>
                </tr><tr>
                  <td>circle line treatment:</td>
                  <td>
                    <select class=dropDown name=torusLineTreatment id='torlt' onChange='buildCanvas()'>
                      <option value=0>SOLID</option>
                      <option value=1>WAVE</option>
                      <option value=2>RIPPLE</option>
                    </select>
                  </td>
                </tr><tr>
                  <td>circle width:</td>
                  <td>
                    <select class=dropDown name=torusWidth id='torw' onChange='buildCanvas()'>
                      <option value=2>2px</option>
                      <option value=3>3px</option>
                      <option value=4>4px</option>
                      <option value=5>5px</option>
                      <option value=6>6px</option>
                      <option value=7>7px</option>
                    </select>
                  </td>
                </tr><tr>
                  <td>circle colour:</td>
                  <td>
                    <span class=tooltip>
                      <input class="jscolor" id='torc' value="000000" size='6' onchange='buildCanvas()'>
                      <span class=tooltiptext>Colour selector for torus circle</span>
                    </span>
                </tr>
              </table>
                  </td>
            </td>
          </tr><tr>
            <td>Torus peg</td>
            <td>
              <table border=1>
                <tr>
                  <td>peg treatment:</td>
                  <td>
                    <select class=dropDown name=pegTreatment id='pegt' onChange='buildCanvas()'>
                      <option value=0>None</option>
                      <option value=1>Circle</option>
                      <option value=2>Square</option>
                      <option value=3>Diamond</option>
                      <option value=4>Heart</option>
                    </select>
                  </td>
                </tr><tr>
                  <td>peg width:</td>
                  <td>
                    <select class=dropDown name=pegWidth id='pegw' onChange='buildCanvas()'>
                      <option value=5>5px</option>
                      <option value=6>6px</option>
                      <option value=7>7px</option>
                      <option value=8>8px</option>
                      <option value=9>9px</option>
                      <option value=10>10px</option>
                    </select>
                  </td>
                </tr><tr>
                  <td>peg colour:</td>
                  <td>
                    <span class=tooltip>
                      <input class="jscolor" id='torpc' value="000000" size='6' onchange='buildCanvas()'>
                      <span class=tooltiptext>Colour selector for pegs</span>
                    </span>
                  </td>
                </tr><tr>
                  <td>peg border colour:</td>
                  <td>
                    <span class=tooltip>
                      <input class="jscolor" id='torpbc' value="000000" size='6' onchange='buildCanvas()'>
                      <span class=tooltiptext>Colour selector for<br/>peg borders</span>
                    </span>
                  </td>
                </tr>
              </table>
            </td>
          </tr>
        </table>

        <h2>Recipient (optional)</h2>
        Recipient: <span class='tooltip'><input class=textInput type='text' name='rep' id='rep' size='40' value='' onChange='buildCanvas()'/><span class='tooltiptext'>Optional name for center of torus</span></span><br>
        Font <span id='recipientProperties'></span>
            <span class='tooltip'><input class="jscolor" id='rc' value="000000" size='6' onchange='buildCanvas()'><span class='tooltiptext'>Colour selector for <b>Recipient</b></span></span> <br>
        <span id=_imageInput>
            Image: <input class=textInput type='text' name='tori' id='tori' size='80' value='' onChange='newImage()'/><br>
        </span>
      </td>
      <td valign=top>
          <table class=imageTable cellpadding=4>
            <tr><td>
              <canvas id=_canvas width=100 height=50 crossOrigin="Anonymous"></canvas>
            </td></tr>
          </table>
      </td>
    </table>

    <br/>
    Debug enabled: <input type=checkbox id='_debug' onChange='buildCanvas()'><br>
    My URL: <span id='_myURL'></span>
    <canvas id=_testCanvas width=5 height=5></canvas>
  </body>
</html>
